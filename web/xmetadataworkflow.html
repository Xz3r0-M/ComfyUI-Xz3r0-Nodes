<!--
    XMetadataWorkflow - ComfyUI å·¥ä½œæµå…ƒæ•°æ®æŸ¥çœ‹å™¨
    ================================================
    ç‰ˆæœ¬: 1.1.0
    æ›´æ–°æ—¥æœŸ: 2026-02-24

    åŠŸèƒ½æ¦‚è¿°:
    ---------
    ä¸€ä¸ªç‹¬ç«‹çš„ç½‘é¡µå·¥å…·ï¼Œç”¨äºæŸ¥çœ‹å’Œåˆ†æ ComfyUI å·¥ä½œæµå…ƒæ•°æ®ï¼Œæ— éœ€å¯åŠ¨ ComfyUI å³å¯é¢„è§ˆå·¥ä½œæµç»“æ„ã€‚

    æ”¯æŒçš„æ–‡ä»¶æ ¼å¼:
    ---------------
    - PNG å›¾ç‰‡ (.png) - åŒ…å«å·¥ä½œæµå…ƒæ•°æ®çš„ç”Ÿæˆå›¾ç‰‡
    - Latent æ½œç©ºé—´æ–‡ä»¶ (.latent) - åŒ…å« __metadata__ çš„æ½œç©ºé—´æ–‡ä»¶
    - JSON å·¥ä½œæµæ–‡ä»¶ (.json) - æ”¯æŒä¸‰ç§æ ¼å¼ï¼š
        * XWorkflowSave ç”Ÿæˆçš„æ ¼å¼ (åŒ…å« prompt å­—æ®µ)
        * ComfyUI ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ (ç›´æ¥æ˜¯ prompt æ•°æ®)
        * ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ (åŒ…å« nodes å’Œ links æ•°ç»„)

    æ ¸å¿ƒåŠŸèƒ½:
    ---------
    1. æ–‡ä»¶è§£æ:
       - PNG: ä» tEXt/iTXt chunk è¯»å– prompt/workflow å…ƒæ•°æ®
       - Latent: ä»æ–‡ä»¶å¤´éƒ¨ JSON è¯»å– __metadata__
       - JSON: æ™ºèƒ½è¯†åˆ«å¹¶è§£æä¸‰ç§å·¥ä½œæµæ ¼å¼

    2. å·¥ä½œæµå¯è§†åŒ–:
       - è‡ªåŠ¨å±‚çº§å¸ƒå±€ç®—æ³•æ’åˆ—èŠ‚ç‚¹
       - æ˜¾ç¤ºèŠ‚ç‚¹ç±»å‹ã€å‚æ•°å’Œè¿æ¥å…³ç³»
       - å­å›¾è‡ªåŠ¨è¯†åˆ«å’Œé¢œè‰²æ ‡è®° (IDæ ¼å¼: "å­å›¾ID:èŠ‚ç‚¹ID")
       - æ”¯æŒç¼©æ”¾ã€å¹³ç§»ã€è‡ªé€‚åº”è§†å›¾

    3. äº¤äº’åŠŸèƒ½:
       - æŠ˜å /å±•å¼€èŠ‚ç‚¹å‚æ•°
       - é€‰ä¸­èŠ‚ç‚¹é«˜äº®ç›¸å…³è¿æ¥ï¼ˆå¸¦æµåŠ¨åŠ¨ç”»æ•ˆæœï¼‰
       - æ‹–æ‹½è°ƒæ•´èŠ‚ç‚¹å®½åº¦
       - èŠ‚ç‚¹æ‹–æ‹½é‡æ–°å¸ƒå±€

    4. ç•Œé¢ç‰¹æ€§:
       - æ”¯æŒæš—é»‘/äº®è‰²ä¸»é¢˜åˆ‡æ¢
       - æ”¯æŒä¸­è‹±æ–‡è¯­è¨€åˆ‡æ¢
       - æ–‡ä»¶ä¿¡æ¯é¢„è§ˆé¢æ¿
       - å“åº”å¼ç¼©æ”¾æ§åˆ¶

    æ•°æ®æ ¼å¼è¯´æ˜:
    -------------
    - å†…éƒ¨ç»Ÿä¸€ä½¿ç”¨ prompt æ ¼å¼ (ComfyUI API æ ¼å¼)
    - å®Œæ•´ Workflow æ ¼å¼ä¼šè‡ªåŠ¨è½¬æ¢ä¸º Prompt API æ ¼å¼
    - èŠ‚ç‚¹ä½ç½®ä½¿ç”¨è‡ªåŠ¨æ’åˆ—ç®—æ³•ï¼Œä¸ä¾èµ–ä¿å­˜çš„ä½ç½®ä¿¡æ¯
    - å­å›¾é€šè¿‡èŠ‚ç‚¹ ID ä¸­çš„ ":" è¯†åˆ« (å¦‚ "18:8" è¡¨ç¤ºå­å›¾18ä¸­çš„èŠ‚ç‚¹8)

    æŠ€æœ¯æ ˆ:
    -------
    - çº¯å‰ç«¯å®ç°ï¼Œæ— éœ€åç«¯æœåŠ¡
    - åŸç”Ÿ JavaScript (ES6+)
    - SVG ç»˜åˆ¶è¿æ¥çº¿
    - CSS3 åŠ¨ç”»æ•ˆæœ

    ä½œè€…: Xz3r0
    é¡¹ç›®: ComfyUI-Xz3r0-Nodes
    è®¸å¯è¯: MIT License
-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMetadataWorkflow</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252525;
            --bg-tertiary: #2a2a2a;
            --bg-canvas: #181818;
            --bg-preview: #1a1a1a;
            --bg-node: #333;
            --bg-node-header: #3d3d3d;
            --bg-param-key: #2a2a2a;
            --bg-param-value: #252525;
            --bg-note: #2a2525;
            --bg-btn: #333;
            --bg-btn-hover: #444;
            --bg-latent-badge: #3d4d5d;

            --border-primary: #3d3d3d;
            --border-secondary: #444;
            --border-tertiary: #555;
            --border-param: #3a3a3a;

            --text-primary: #fff;
            --text-secondary: #ddd;
            --text-tertiary: #aaa;
            --text-muted: #888;
            --text-dim: #666;
            --text-placeholder: #555;
            --text-hint: #444;

            --accent: #ff69b4;
            --accent-hover: rgba(123, 104, 238, 0.05);

            --connection-line: #555;
            --resize-handle: #555;

            --shadow-node: rgba(0, 0, 0, 0.3);
            --shadow-node-hover: rgba(0, 0, 0, 0.4);
            --shadow-selected: rgba(200, 200, 200, 0.6);

            --dot-pattern: #2a2a2a;

            --header-btn-bg: rgba(255, 255, 255, 0.1);
            --header-btn-bg-hover: rgba(255, 255, 255, 0.2);
        }

        [data-theme="light"] {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f0f0f0;
            --bg-canvas: #e8e8e8;
            --bg-preview: #f0f0f0;
            --bg-node: #ffffff;
            --bg-node-header: #e8e8e8;
            --bg-param-key: #f0f0f0;
            --bg-param-value: #f8f8f8;
            --bg-note: #f8f0f0;
            --bg-btn: #ffffff;
            --bg-btn-hover: #f0f0f0;
            --bg-latent-badge: #e0e8f0;

            --border-primary: #ddd;
            --border-secondary: #ccc;
            --border-tertiary: #bbb;
            --border-param: #e0e0e0;

            --text-primary: #1a1a1a;
            --text-secondary: #333;
            --text-tertiary: #555;
            --text-muted: #666;
            --text-dim: #888;
            --text-placeholder: #999;
            --text-hint: #aaa;

            --accent: #ff69b4;
            --accent-hover: rgba(255, 105, 180, 0.1);

            --connection-line: #aaa;
            --resize-handle: #bbb;

            --shadow-node: rgba(0, 0, 0, 0.1);
            --shadow-node-hover: rgba(0, 0, 0, 0.15);
            --shadow-selected: rgba(255, 105, 180, 0.4);

            --dot-pattern: #d0d0d0;

            --header-btn-bg: rgba(0, 0, 0, 0.05);
            --header-btn-bg-hover: rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-secondary);
            height: 100vh;
            overflow: hidden;
        }

        .file-input {
            display: none;
        }

        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 12px 15px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .language-switch {
            display: flex;
            padding: 10px 15px;
            border-top: 1px solid var(--border-primary);
            gap: 8px;
            justify-content: center;
        }

        .lang-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-muted);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .lang-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .lang-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .theme-switch {
            display: flex;
            padding: 10px 15px;
            border-top: 1px solid var(--border-primary);
            gap: 8px;
            justify-content: center;
        }

        .theme-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .theme-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .theme-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }

        .theme-btn[data-theme="dark"]:not(.active) {
            background: #1a1a1a;
            border-color: #1a1a1a;
            color: #fff;
        }

        .theme-btn[data-theme="light"]:not(.active) {
            background: #ffffff;
            border-color: #ffffff;
            color: #1a1a1a;
        }

        .file-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 15px;
        }

        .file-area .file-input {
            display: none;
        }

        .file-area .file-preview {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-preview);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 1px solid var(--border-primary);
        }

        .file-area .file-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .file-area .file-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-placeholder);
            cursor: pointer;
            padding: 20px;
            width: 100%;
            height: 100%;
            border: 2px dashed transparent;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .file-area .file-placeholder:hover {
            border-color: var(--accent);
            background: var(--accent-hover);
        }

        .file-area .file-placeholder .icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .file-area .file-placeholder span {
            font-size: 12px;
            white-space: pre-line;
            text-align: center;
        }

        .file-area .file-placeholder .hint {
            font-size: 10px;
            color: var(--text-hint);
            margin-top: 4px;
        }

        .file-area .file-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-area .file-info-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 11px;
        }

        .file-area .file-info-item .label {
            color: var(--text-dim);
            flex-shrink: 0;
        }

        .file-area .file-info-item .value {
            color: var(--text-tertiary);
            text-align: right;
            word-break: break-all;
            margin-left: 10px;
        }

        .file-area .file-info-item .value.latent-badge {
            display: inline-block;
            background: var(--bg-latent-badge);
            color: var(--accent);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-canvas);
            background-image:
                radial-gradient(circle, var(--dot-pattern) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #canvas-wrapper {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .svg-connections {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .connection-line {
            stroke: var(--connection-line);
            stroke-width: 2;
            fill: none;
            transition: all 0.3s ease;
        }

        .connection-line.highlight {
            stroke: var(--accent);
            stroke-width: 3;
            animation: line-flow 1.5s linear infinite;
        }

        .connection-line-base {
            stroke: var(--connection-line);
            stroke-width: 2;
            fill: none;
        }

        .connection-line-flow {
            stroke: var(--accent);
            stroke-width: 3;
            fill: none;
            animation: line-flow 1.5s linear infinite;
        }

        @keyframes line-flow {
            0% {
                stroke-dasharray: 10, 20;
                stroke-dashoffset: 0;
            }
            100% {
                stroke-dasharray: 10, 20;
                stroke-dashoffset: -30;
            }
        }

        .node {
            position: absolute;
            background: var(--bg-node);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            min-width: 180px;
            width: 220px;
            z-index: 10;
            box-shadow: 0 4px 12px var(--shadow-node);
            transition: box-shadow 0.1s, border-color 0.3s;
            overflow: hidden;
            resize: horizontal;
        }

        .node:hover {
            box-shadow: 0 6px 16px var(--shadow-node-hover);
        }

        .node.selected {
            border-color: var(--border-tertiary) !important;
            box-shadow: 0 0 20px var(--shadow-selected), 0 0 40px var(--shadow-selected), 0 0 0 2px var(--shadow-selected) !important;
            animation: node-glow 2s ease-in-out infinite alternate;
        }

        @keyframes node-glow {
            0% {
                box-shadow: 0 0 20px var(--shadow-selected), 0 0 40px var(--shadow-selected), 0 0 0 2px var(--shadow-selected);
            }
            100% {
                box-shadow: 0 0 30px var(--shadow-selected), 0 0 60px var(--shadow-selected), 0 0 0 3px var(--shadow-selected);
            }
        }

        .node.collapsed .node-body {
            display: none;
        }

        .subgraph-tag {
            font-size: 9px;
            color: #fff;
            padding: 3px 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid var(--border-primary);
        }

        .node-id-tag {
            font-size: 9px;
            color: var(--text-muted);
            padding: 3px 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
        }

        .node-header {
            padding: 6px 10px;
            background: var(--bg-node-header);
            border-radius: 7px 7px 0 0;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: move;
            border-bottom: 1px solid var(--border-tertiary);
        }

        .header-actions {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }

        .header-btn {
            width: 18px;
            height: 18px;
            border: none;
            background: var(--header-btn-bg);
            color: var(--text-tertiary);
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.1s;
        }

        .header-btn:hover {
            background: var(--header-btn-bg-hover);
            color: var(--text-primary);
        }

        .node-body {
            padding: 8px 10px;
            font-size: 10px;
            color: var(--text-tertiary);
            max-height: none;
            overflow-y: visible;
        }

        .node-body::-webkit-scrollbar {
            width: 4px;
        }

        .node-body::-webkit-scrollbar-track {
            background: transparent;
        }

        .node-body::-webkit-scrollbar-thumb {
            background: var(--border-tertiary);
            border-radius: 2px;
        }

        .param-row {
            display: flex;
            padding: 2px 0;
            gap: 8px;
            flex-wrap: wrap;
            border-bottom: 1px solid var(--border-param);
        }

        .param-key {
            color: var(--text-muted);
            flex-shrink: 0;
            overflow: visible;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: var(--bg-param-key);
            padding: 1px 4px;
            border-radius: 2px;
            text-align: left;
        }

        .param-value {
            color: var(--text-secondary);
            word-break: break-all;
            text-align: left;
            flex: 1;
            overflow: auto;
            text-overflow: clip;
            white-space: pre-wrap;
            word-wrap: break-word;
            background: var(--bg-param-value);
            padding: 1px 4px;
            border-radius: 2px;
            max-height: 100px;
        }

        .param-value::-webkit-scrollbar {
            width: 3px;
            height: 3px;
        }

        .param-value::-webkit-scrollbar-track {
            background: transparent;
        }

        .param-value::-webkit-scrollbar-thumb {
            background: var(--border-tertiary);
            border-radius: 2px;
        }

        .note-node .node-body {
            padding: 8px;
        }

        .note-content {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: pre-wrap;
            background: var(--bg-note);
            padding: 8px;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
        }

        .zoom-controls {
            position: fixed;
            bottom: 10px;
            right: 20px;
            display: flex;
            gap: 4px;
            z-index: 100;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-secondary);
            background: var(--bg-btn);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .zoom-btn:hover {
            background: var(--bg-btn-hover);
            border-color: var(--border-tertiary);
        }

        .zoom-level {
            width: 50px;
            padding: 0 5px;
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            background: var(--bg-btn);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            text-align: center;
        }

        .zoom-level:focus {
            outline: none;
            border-color: var(--accent);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">XMetadataWorkflow</div>
            <div class="file-area" id="fileArea">
                <input type="file" id="fileInput" class="file-input" accept=".png,.latent,.json">
                <div class="file-preview" id="filePreview">
                    <div class="file-placeholder" id="filePlaceholder">
                        <span class="icon">ğŸ“</span>
                        <span data-i18n="DroporSelect">æ‹–æ”¾æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</span>
                        <span class="hint" data-i18n="filetip"></span>
                    </div>
                </div>
                <div class="file-info" id="fileInfo">
                    <div class="file-info-item">
                        <span class="label" data-i18n="filename">æ–‡ä»¶å</span>
                        <span class="value" id="infoFilename">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="filetype">ç±»å‹</span>
                        <span class="value" id="infoType">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="filesize">å¤§å°</span>
                        <span class="value" id="infoSize">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="resolution">åˆ†è¾¨ç‡</span>
                        <span class="value" id="infoResolution">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="modified">ä¿®æ”¹æ—¥æœŸ</span>
                        <span class="value" id="infoModified">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="nodes">èŠ‚ç‚¹</span>
                        <span class="value" id="infoNodeCount">-</span>
                    </div>
                </div>
            </div>
            <div class="language-switch" id="languageSwitch">
                <button class="lang-btn" data-lang="zh" data-i18n="langZh">ä¸­æ–‡</button>
                <button class="lang-btn" data-lang="en" data-i18n="langEn">EN</button>
            </div>
            <div class="theme-switch" id="themeSwitch">
                <button class="theme-btn" data-theme="dark" data-i18n-title="darkMode">ğŸŒ™</button>
                <button class="theme-btn" data-theme="light" data-i18n-title="lightMode">â˜€ï¸</button>
            </div>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <div id="canvas-wrapper">
                <svg class="svg-connections" id="connections"></svg>
                <div id="canvas"></div>
            </div>
        </div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOut" title="ç¼©å°" data-i18n-title="zoomOut">â–</button>
        <input type="number" class="zoom-level" id="zoomLevel" value="100" min="10" max="500" title="è¾“å…¥ç¼©æ”¾ç™¾åˆ†æ¯”" data-i18n-title="zoomLevel">
        <span style="color: #888; font-size: 11px;"></span>
        <button class="zoom-btn" id="zoomIn" title="æ”¾å¤§" data-i18n-title="zoomIn">â•</button>
        <button class="zoom-btn" id="zoomReset" title="é‡ç½®åˆ°100%" data-i18n-title="zoomReset">ğŸ”</button>
        <button class="zoom-btn" id="zoomFit" title="é€‚åº”çª—å£" data-i18n-title="zoomFit">â˜‘ï¸</button>
    </div>

    <script>
        const SUBGRAPH_COLORS = [
            '#8b0000', '#1b237e', '#1b5e20', '#4a148c', '#bf360c',
            '#004d40', '#880e4f', '#004d40', '#33691e', '#bf360c',
            '#311b92', '#e65100', '#01579b', '#1b5e20', '#e65100',
            '#3e2723', '#263238', '#827717', '#f57f17', '#004d40'
        ];

        const i18n = {
            zh: {
                title: 'XMetadataWorkflow',
                langZh: 'ä¸­æ–‡',
                langEn: 'English',
                DroporSelect: 'æ‹–æ”¾æ–‡ä»¶åˆ°æ­¤å¤„ æˆ– ç‚¹å‡»é€‰æ‹©æ–‡ä»¶',
                filetip: 'æ”¯æŒ .png å’Œ .latent\nä»¥åŠ .json (ä¸‰ç§æ ¼å¼)',
                filename: 'æ–‡ä»¶å',
                filetype: 'ç±»å‹',
                filesize: 'å¤§å°',
                resolution: 'åˆ†è¾¨ç‡',
                modified: 'ä¿®æ”¹æ—¥æœŸ',
                nodes: 'èŠ‚ç‚¹',
                zoomOut: 'ç¼©å°',
                zoomIn: 'æ”¾å¤§',
                zoomReset: 'é‡ç½®åˆ°100%',
                zoomFit: 'é€‚åº”çª—å£',
                zoomLevel: 'è¾“å…¥ç¼©æ”¾ç™¾åˆ†æ¯”',
                toggleCollapse: 'æœ€å°åŒ–',
                expand: 'å±•å¼€',
                detail: 'è¯¦æƒ…',
                bypass: 'å·² Bypass',
                latent: 'Latent',
                inputParams: 'è¾“å…¥å‚æ•°',
                subgraph: 'å­å›¾',
                status: 'çŠ¶æ€',
                input: 'è¾“å…¥',
                output: 'è¾“å‡º',
                darkMode: 'æš—é»‘æ¨¡å¼',
                lightMode: 'äº®è‰²æ¨¡å¼',
                noPromptError: 'ä¸æ”¯æŒçš„ JSON æ ¼å¼\n\næ­¤ JSON æ–‡ä»¶æ— æ³•è¯†åˆ«ä¸ºæœ‰æ•ˆçš„å·¥ä½œæµæ ¼å¼ã€‚\n\næ”¯æŒçš„æ ¼å¼ï¼š\nâ€¢ XWorkflowSave ç”Ÿæˆçš„ JSON (å« prompt å­—æ®µ)\nâ€¢ ComfyUI ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ JSON\nâ€¢ ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ JSON\nâ€¢ åŒ…å« prompt å…ƒæ•°æ®çš„ PNG å›¾ç‰‡\nâ€¢ Latent æ½œç©ºé—´æ–‡ä»¶',
                latentFile: 'Latent æ½œç©ºé—´',
                jsonWorkflow: 'JSON å·¥ä½œæµ',
                noPreview: 'æ— æ³•ç›´æ¥é¢„è§ˆ',
                clickToChange: 'ç‚¹å‡»æ›´æ¢æ–‡ä»¶',
                typePng: 'PNG å›¾ç‰‡',
                typeLatent: 'Latent æ½œç©ºé—´',
                typeJson: 'JSON å·¥ä½œæµ',
                unknown: 'æœªçŸ¥'
            },
            en: {
                title: 'XMetadataWorkflow',
                langZh: 'ä¸­æ–‡',
                langEn: 'English',
                DroporSelect: 'Drop file here\nor click to select',
                filetip: 'Supports .png, .latent\nand .json (three formats)',
                filename: 'Filename',
                filetype: 'Type',
                filesize: 'Size',
                resolution: 'Resolution',
                modified: 'Modified',
                nodes: 'Nodes',
                zoomOut: 'Zoom Out',
                zoomIn: 'Zoom In',
                zoomReset: 'Reset 100%',
                zoomFit: 'Fit Window',
                zoomLevel: 'Enter zoom percentage',
                toggleCollapse: 'Collapse',
                expand: 'Expand',
                detail: 'Detail',
                bypass: 'Bypassed',
                latent: 'Latent',
                inputParams: 'Input Params',
                subgraph: 'Subgraph',
                status: 'Status',
                input: 'Input',
                output: 'Output',
                darkMode: 'Dark Mode',
                lightMode: 'Light Mode',
                noPromptError: 'Unsupported JSON Format\n\nThis JSON file cannot be recognized as a valid workflow format.\n\nSupported formats:\nâ€¢ JSON from XWorkflowSave (with prompt field)\nâ€¢ ComfyUI web-exported API format JSON\nâ€¢ ComfyUI web-saved full Workflow format JSON\nâ€¢ PNG images with prompt metadata\nâ€¢ Latent files',
                latentFile: 'Latent File',
                jsonWorkflow: 'JSON Workflow',
                noPreview: 'No preview available',
                clickToChange: 'Click to change file',
                typePng: 'PNG Image',
                typeLatent: 'Latent File',
                typeJson: 'JSON Workflow',
                unknown: 'Unknown'
            }
        };

        const browserLang = navigator.language || navigator.userLanguage || 'en';
        let currentLang = browserLang.startsWith('zh') ? 'zh' : 'en';

        /**
         * å›½é™…åŒ–ç¿»è¯‘å‡½æ•°
         * @param {string} key - ç¿»è¯‘é”®å
         * @returns {string} ç¿»è¯‘åçš„æ–‡æœ¬ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›é”®å
         */
        function t(key) {
            return i18n[currentLang][key] || key;
        }

        /**
         * æ ¹æ®å­å›¾IDç”Ÿæˆé¢œè‰²
         * ä½¿ç”¨å“ˆå¸Œç®—æ³•ç¡®ä¿åŒä¸€å­å›¾å§‹ç»ˆè·å¾—ç›¸åŒé¢œè‰²
         * @param {string} subgraphId - å­å›¾ID
         * @returns {string} HSLé¢œè‰²å­—ç¬¦ä¸²
         */
        function getSubgraphColor(subgraphId) {
            if (!subgraphId) return null;
            let hash = 0;
            const idStr = String(subgraphId);
            for (let i = 0; i < idStr.length; i++) {
                hash = idStr.charCodeAt(i) + ((hash << 5) - hash);
            }
            const index = Math.abs(hash) % SUBGRAPH_COLORS.length;
            return SUBGRAPH_COLORS[index];
        }

        let workflowData = null;
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let nodeStates = {};
        let selectedNodeId = null;
        let currentFileType = null; // å­˜å‚¨å½“å‰æ–‡ä»¶ç±»å‹ï¼Œç”¨äºè¯­è¨€åˆ‡æ¢æ—¶æ›´æ–°é¢„è§ˆ

        const canvasContainer = document.getElementById('canvasContainer');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const connectionsSvg = document.getElementById('connections');
        const zoomLevel = document.getElementById('zoomLevel');

        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLang = btn.dataset.lang;
                updateLanguage();
            });
        });

        document.querySelector(`.lang-btn[data-lang="${currentLang}"]`).classList.add('active');
        updateLanguage();

        let currentTheme = localStorage.getItem('theme') || 'dark';

        /**
         * è®¾ç½®é¡µé¢ä¸»é¢˜ï¼ˆäº®è‰²/æš—è‰²ï¼‰
         * @param {string} theme - ä¸»é¢˜åç§° 'dark' æˆ– 'light'
         */
        function setTheme(theme) {
            currentTheme = theme;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.theme-btn[data-theme="${theme}"]`).classList.add('active');
        }

        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setTheme(btn.dataset.theme);
            });
        });

        setTheme(currentTheme);

        function updateLanguage() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = t(key);
            });
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                el.title = t(key);
            });

            // æ›´æ–°æ–‡ä»¶ä¿¡æ¯åŒºåŸŸçš„ç±»å‹æ˜¾ç¤º
            if (currentFileType) {
                const typeMap = {
                    'png': t('typePng'),
                    'latent': t('typeLatent'),
                    'json': t('typeJson')
                };
                document.getElementById('infoType').textContent = typeMap[currentFileType] || currentFileType;

                // æ›´æ–°é¢„è§ˆåŒºåŸŸçš„æ–‡æœ¬
                if (currentFileType === 'latent') {
                    displayLatentPreview();
                } else if (currentFileType === 'json') {
                    displayNoPreview();
                } else if (currentFileType === 'png') {
                    // æ›´æ–° PNG é¢„è§ˆçš„ title
                    const placeholder = document.getElementById('filePlaceholder');
                    if (placeholder) {
                        placeholder.title = t('clickToChange');
                    }
                }
            }

            renderWorkflow();
        }

        const fileArea = document.getElementById('fileArea');
        const filePlaceholder = document.getElementById('filePlaceholder');
        const fileInput = document.getElementById('fileInput');

        filePlaceholder.addEventListener('click', () => fileInput.click());
        fileArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            filePlaceholder.classList.add('dragover');
        });
        fileArea.addEventListener('dragleave', () => {
            filePlaceholder.classList.remove('dragover');
        });
        fileArea.addEventListener('drop', (e) => {
            e.preventDefault();
            filePlaceholder.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        });
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        document.getElementById('zoomIn').addEventListener('click', () => {
            setZoom(scale * 1.2, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });
        document.getElementById('zoomOut').addEventListener('click', () => {
            setZoom(scale / 1.2, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });
        document.getElementById('zoomReset').addEventListener('click', () => {
            setZoom(1, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });
        document.getElementById('zoomFit').addEventListener('click', () => {
            fitToView();
        });

        zoomLevel.addEventListener('change', () => {
            const newScale = Math.max(0.1, Math.min(5, parseInt(zoomLevel.value) / 100));
            setZoom(newScale, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });

        /**
         * è‡ªé€‚åº”è§†å›¾ - ç¼©æ”¾å’Œå¹³ç§»ä»¥æ˜¾ç¤ºæ‰€æœ‰èŠ‚ç‚¹
         * è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†ï¼Œç„¶åè°ƒæ•´ç¼©æ”¾å’Œå¹³ç§»ä½¿æ‰€æœ‰èŠ‚ç‚¹å¯è§
         */
        function fitToView() {
            if (!workflowData || !workflowData.nodes) return;

            const nodes = document.querySelectorAll('.node');
            if (nodes.length === 0) return;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†
            nodes.forEach(node => {
                const x = parseFloat(node.style.left);
                const y = parseFloat(node.style.top);
                const w = node.offsetWidth;
                const h = node.offsetHeight;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + w);
                maxY = Math.max(maxY, y + h);
            });

            const contentWidth = maxX - minX + 100;
            const contentHeight = maxY - minY + 100;

            // è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹
            const scaleX = canvasContainer.clientWidth / contentWidth;
            const scaleY = canvasContainer.clientHeight / contentHeight;
            const newScale = Math.min(scaleX, scaleY, 2);

            // è®¡ç®—å¹³ç§»é‡ä½¿å†…å®¹å±…ä¸­
            const contentCenterX = (minX + maxX) / 2 * newScale;
            const contentCenterY = (minY + maxY) / 2 * newScale;
            const containerCenterX = canvasContainer.clientWidth / 2;
            const containerCenterY = canvasContainer.clientHeight / 2;

            panX = containerCenterX - contentCenterX;
            panY = containerCenterY - contentCenterY;

            scale = newScale;
            updateTransform();
        }

        document.addEventListener('wheel', (e) => {
            if (!workflowData || !workflowData.nodes) return;
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            setZoom(scale * delta, e.clientX, e.clientY);
        }, { passive: false });

        let isPanning = false;
        let panStartX, panStartY;

        canvasContainer.addEventListener('mousedown', (e) => {
            if (e.target === canvasContainer || e.target === canvasWrapper) {
                isPanning = true;
                panStartX = e.clientX - panX;
                panStartY = e.clientY - panY;
                canvasContainer.style.cursor = 'grabbing';
            }
        });

        canvasContainer.addEventListener('dblclick', (e) => {
            if (e.target === canvasContainer || e.target === canvasWrapper) {
                deselectAll();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (document.activeElement.tagName === 'INPUT') {
                    document.activeElement.blur();
                } else {
                    deselectAll();
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isPanning) {
                panX = e.clientX - panStartX;
                panY = e.clientY - panStartY;
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'default';
        });

        /**
         * è®¾ç½®ç”»å¸ƒç¼©æ”¾çº§åˆ«
         * @param {number} newScale - æ–°çš„ç¼©æ”¾æ¯”ä¾‹
         * @param {number} centerX - ç¼©æ”¾ä¸­å¿ƒç‚¹ X åæ ‡
         * @param {number} centerY - ç¼©æ”¾ä¸­å¿ƒç‚¹ Y åæ ‡
         */
        function setZoom(newScale, centerX, centerY) {
            newScale = Math.max(0.1, Math.min(5, newScale));

            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = centerX - rect.left;
            const mouseY = centerY - rect.top;

            // ä»¥é¼ æ ‡ä½ç½®ä¸ºä¸­å¿ƒè¿›è¡Œç¼©æ”¾
            const scaleChange = newScale / scale;
            panX = mouseX - (mouseX - panX) * scaleChange;
            panY = mouseY - (mouseY - panY) * scaleChange;

            scale = newScale;
            updateTransform();
        }

        /**
         * æ›´æ–°ç”»å¸ƒçš„å˜æ¢ï¼ˆå¹³ç§»å’Œç¼©æ”¾ï¼‰
         * åŒæ—¶æ›´æ–°ç¼©æ”¾çº§åˆ«æ˜¾ç¤ºå’Œè¿æ¥çº¿ä½ç½®
         */
        function updateTransform() {
            canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            zoomLevel.value = Math.round(scale * 100);
            updateConnectionPaths();
        }

        /**
         * å¤„ç†ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶
         * æµç¨‹ï¼šè¯»å–æ–‡ä»¶ -> æå–å…ƒæ•°æ® -> è§£æå·¥ä½œæµ -> æ¸²æŸ“ -> è‡ªé€‚åº”è§†å›¾
         * @param {File} file - ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶å¯¹è±¡
         */
        async function handleFile(file) {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);

            try {
                const metadata = await readMetadataFromFile(uint8Array, file.name);
                if (!metadata) {
                    return;
                }

                updateFileInfo(file, uint8Array);

                // è§£æå·¥ä½œæµæ•°æ®
                workflowData = parseWorkflow(metadata);

                // é‡ç½®è§†å›¾çŠ¶æ€
                scale = 1;
                panX = 50;
                panY = 50;
                nodeStates = {};

                // æ¸²æŸ“å¹¶è‡ªé€‚åº”è§†å›¾
                renderWorkflow();
                fitToView();

                document.getElementById('infoNodeCount').textContent = Object.keys(workflowData.nodes).length;
            } catch (error) {
                console.error(error);
            }
        }

        /**
         * æ›´æ–°æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤º
         * @param {File} file - æ–‡ä»¶å¯¹è±¡
         * @param {Uint8Array} uint8Array - æ–‡ä»¶å†…å®¹çš„äºŒè¿›åˆ¶æ•°æ®
         */
        function updateFileInfo(file, uint8Array) {
            const filename = file.name;
            const ext = filename.split('.').pop().toLowerCase();
            const size = formatFileSize(file.size);
            const lastModified = new Date(file.lastModified).toLocaleString(currentLang === 'zh' ? 'zh-CN' : 'en-US');

            // ä¿å­˜å½“å‰æ–‡ä»¶ç±»å‹ï¼Œç”¨äºè¯­è¨€åˆ‡æ¢æ—¶æ›´æ–°
            currentFileType = ext;

            document.getElementById('infoFilename').textContent = filename;
            document.getElementById('infoSize').textContent = size;
            document.getElementById('infoModified').textContent = lastModified;

            // ä½¿ç”¨ i18n è·å–æ–‡ä»¶ç±»å‹åç§°
            const typeMap = {
                'png': t('typePng'),
                'latent': t('typeLatent'),
                'json': t('typeJson')
            };
            document.getElementById('infoType').textContent = typeMap[ext] || ext;

            // æ ¹æ®æ–‡ä»¶ç±»å‹æ˜¾ç¤ºä¸åŒçš„é¢„è§ˆå’Œä¿¡æ¯
            if (ext === 'png') {
                const dims = getPngDimensions(uint8Array);
                if (dims) {
                    document.getElementById('infoResolution').textContent = `${dims.width} Ã— ${dims.height}`;
                    displayImagePreview(uint8Array);
                } else {
                    document.getElementById('infoResolution').textContent = t('unknown');
                }
            } else if (ext === 'latent') {
                document.getElementById('infoResolution').innerHTML = `<span class="latent-badge">${t('latent')}</span>`;
                displayLatentPreview();
            } else {
                document.getElementById('infoResolution').textContent = '-';
                displayNoPreview();
            }
        }

        /**
         * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°ä¸ºæ˜“è¯»æ ¼å¼
         * @param {number} bytes - å­—èŠ‚æ•°
         * @returns {string} æ ¼å¼åŒ–åçš„æ–‡ä»¶å¤§å° (å¦‚ "1.5 MB")
         */
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        /**
         * ä» PNG äºŒè¿›åˆ¶æ•°æ®ä¸­æå–å›¾ç‰‡å°ºå¯¸
         * è§£æ IHDR chunk è·å–å®½åº¦å’Œé«˜åº¦
         * @param {Uint8Array} data - PNG æ–‡ä»¶çš„äºŒè¿›åˆ¶æ•°æ®
         * @returns {Object|null} åŒ…å« width å’Œ height çš„å¯¹è±¡ï¼Œè§£æå¤±è´¥è¿”å› null
         */
        function getPngDimensions(data) {
            try {
                if (data.length < 24) return null;

                // éªŒè¯ PNG æ–‡ä»¶ç­¾å
                const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
                for (let i = 0; i < 8; i++) {
                    if (data[i] !== pngSignature[i]) return null;
                }

                // éå† chunks æŸ¥æ‰¾ IHDR
                let offset = 8;
                while (offset < data.length - 12) {
                    const length = (data[offset] << 24) | (data[offset + 1] << 16) |
                                   (data[offset + 2] << 8) | data[offset + 3];

                    const type = String.fromCharCode(
                        data[offset + 4], data[offset + 5],
                        data[offset + 6], data[offset + 7]
                    );

                    if (type === 'IHDR') {
                        const width = (data[offset + 8] << 24) | (data[offset + 9] << 16) |
                                     (data[offset + 10] << 8) | data[offset + 11];
                        const height = (data[offset + 12] << 24) | (data[offset + 13] << 16) |
                                      (data[offset + 14] << 8) | data[offset + 15];
                        return { width, height };
                    }

                    if (type === 'IEND') break;
                    offset += 12 + length;
                }
            } catch (e) {
                console.error('Error getting PNG dimensions:', e);
            }
            return null;
        }

        /**
         * æ˜¾ç¤º PNG å›¾ç‰‡é¢„è§ˆ
         * @param {Uint8Array} uint8Array - PNG æ–‡ä»¶çš„äºŒè¿›åˆ¶æ•°æ®
         */
        function displayImagePreview(uint8Array) {
            const blob = new Blob([uint8Array], { type: 'image/png' });
            const url = URL.createObjectURL(blob);

            const preview = document.getElementById('filePreview');
            const placeholder = document.getElementById('filePlaceholder');

            placeholder.innerHTML = '<img src="' + url + '" alt="Preview" style="max-width: 100%; max-height: 100%; object-fit: contain;">';
            placeholder.style.cursor = 'pointer';
            placeholder.title = t('clickToChange');
        }

        function displayLatentPreview() {
            const placeholder = document.getElementById('filePlaceholder');
            placeholder.innerHTML = `
                <span class="icon">ğŸ§ </span>
                <span>${t('latentFile')}</span>
                <span style="font-size: 10px; color: #555; margin-top: 8px;">${t('noPreview')}</span>
                <span style="font-size: 10px; color: #444; margin-top: 4px;">${t('clickToChange')}</span>
            `;
        }

        function displayNoPreview() {
            const placeholder = document.getElementById('filePlaceholder');
            placeholder.innerHTML = `
                <span class="icon">ğŸ“„</span>
                <span>${t('jsonWorkflow')}</span>
                <span style="font-size: 10px; color: #444; margin-top: 4px;">${t('clickToChange')}</span>
            `;
        }

        /**
         * æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©å¯¹åº”çš„å…ƒæ•°æ®è¯»å–å‡½æ•°
         * å¤„ç†æµç¨‹ï¼š
         * 1. .latent æ–‡ä»¶ -> readLatentMetadata (è¯»å– latent æ–‡ä»¶çš„å¤´éƒ¨å…ƒæ•°æ®)
         * 2. .json æ–‡ä»¶ -> readJsonMetadata (è‡ªåŠ¨è¯†åˆ«å¹¶è§£æä¸¤ç§ prompt æ ¼å¼)
         * 3. å…¶ä»–æ–‡ä»¶ (å¦‚ .png) -> readPngMetadata (ä» PNG çš„ tEXt/iTXt chunk è¯»å–)
         */
        async function readMetadataFromFile(data, filename) {
            if (filename.toLowerCase().endsWith('.latent')) {
                return readLatentMetadata(data);
            } else if (filename.toLowerCase().endsWith('.json')) {
                return readJsonMetadata(data);
            } else {
                return readPngMetadata(data);
            }
        }

        /**
         * å°†å®Œæ•´ Workflow æ ¼å¼è½¬æ¢ä¸º Prompt API æ ¼å¼
         * å®Œæ•´ Workflow æ ¼å¼åŒ…å«æ›´å¤šå…ƒæ•°æ®ï¼ˆèŠ‚ç‚¹ä½ç½®ã€å¤§å°ç­‰ï¼‰ï¼Œä½†éœ€è¦è½¬æ¢æ‰èƒ½ä½¿ç”¨
         *
         * @param {Object} workflow - å®Œæ•´ Workflow æ ¼å¼çš„ JSON å¯¹è±¡
         * @returns {Object} - Prompt API æ ¼å¼çš„å¯¹è±¡
         */
        function convertWorkflowToPrompt(workflow) {
            const prompt = {};
            const nodeMap = new Map();

            // é¦–å…ˆå»ºç«‹èŠ‚ç‚¹ ID æ˜ å°„
            for (const node of workflow.nodes || []) {
                nodeMap.set(node.id, node);
            }

            // æ„å»ºé“¾æ¥æ˜ å°„ï¼šlinkId -> { origin_id, origin_slot, target_id, target_slot }
            const linkMap = new Map();
            for (const link of workflow.links || []) {
                // link æ ¼å¼: [id, origin_id, origin_slot, target_id, target_slot, type]
                if (link.length >= 5) {
                    linkMap.set(link[0], {
                        origin_id: link[1],
                        origin_slot: link[2],
                        target_id: link[3],
                        target_slot: link[4]
                    });
                }
            }

            // è½¬æ¢æ¯ä¸ªèŠ‚ç‚¹
            for (const node of workflow.nodes || []) {
                const nodeData = {
                    inputs: {},
                    class_type: node.type,
                    _meta: {
                        title: node.properties?.["Node name for S&R"] || node.type
                    }
                };

                // å¤„ç† Note å’Œ MarkdownNote èŠ‚ç‚¹ï¼ˆæ²¡æœ‰ inputsï¼Œä½†æœ‰ widgets_valuesï¼‰
                if (node.type === 'Note' || node.type === 'MarkdownNote') {
                    if (node.widgets_values && node.widgets_values.length > 0) {
                        nodeData.inputs.text = node.widgets_values[0];
                    }
                    prompt[String(node.id)] = nodeData;
                    continue;
                }

                // æ”¶é›†è¯¥èŠ‚ç‚¹ä½œä¸ºç›®æ ‡çš„æ‰€æœ‰é“¾æ¥ï¼ˆç”¨äºç¡®å®šè¾“å…¥è¿æ¥ï¼‰
                const incomingLinks = [];
                for (const [linkId, linkInfo] of linkMap) {
                    if (linkInfo.target_id === node.id) {
                        incomingLinks.push(linkInfo);
                    }
                }

                // å¤„ç† widgets_values å’Œ inputs çš„é…å¯¹
                let widgetIndex = 0;

                for (const input of node.inputs || []) {
                    if (input.link !== undefined && input.link !== null) {
                        // ä¼˜å…ˆå¤„ç†è¿æ¥è¾“å…¥ï¼ˆå³ä½¿ input ä¹Ÿæœ‰ widgetï¼‰
                        const linkInfo = linkMap.get(input.link);
                        if (linkInfo) {
                            nodeData.inputs[input.name] = [
                                String(linkInfo.origin_id),
                                linkInfo.origin_slot
                            ];
                        }
                        // å¦‚æœè¿™ä¸ªè¾“å…¥ä¹Ÿæœ‰ widgetï¼Œéœ€è¦è·³è¿‡å¯¹åº”çš„ widgetIndex
                        if (input.widget && node.widgets_values) {
                            widgetIndex++;
                        }
                    } else if (input.widget && node.widgets_values && widgetIndex < node.widgets_values.length) {
                        // è¿™æ˜¯ widget å‚æ•°ï¼ˆæ²¡æœ‰è¿æ¥ï¼‰ï¼Œä» widgets_values å–å€¼
                        nodeData.inputs[input.name] = node.widgets_values[widgetIndex];
                        widgetIndex++;
                    }
                }

                prompt[String(node.id)] = nodeData;
            }

            return prompt;
        }

        /**
         * è¯»å– JSON æ–‡ä»¶çš„å…ƒæ•°æ®
         * å¤„ç†é€»è¾‘ï¼š
         * - æ”¯æŒåŒ…å« prompt å­—æ®µçš„ JSON (å¦‚ XWorkflowSave ç”Ÿæˆçš„)
         * - æ”¯æŒ ComfyUI å®˜æ–¹ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ JSON (ç›´æ¥æ˜¯ prompt æ•°æ®)
         * - æ”¯æŒ ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ JSON (åŒ…å« nodes æ•°ç»„)
         * - è¿”å›æ ¼å¼: { prompt: {...} }
         */
        async function readJsonMetadata(data) {
            try {
                const textDecoder = new TextDecoder('utf-8');
                const text = textDecoder.decode(data);
                const json = JSON.parse(text);

                // æƒ…å†µ1: åŒ…å« prompt å­—æ®µçš„ JSON (XWorkflowSave)
                if (json.prompt) {
                    return { prompt: json.prompt };
                }

                // æƒ…å†µ2: ComfyUI å®˜æ–¹ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ JSON
                // ç‰¹å¾: ç›´æ¥æ˜¯èŠ‚ç‚¹æ˜ å°„è¡¨ï¼Œé”®æ˜¯æ•°å­—å­—ç¬¦ä¸²ï¼Œå€¼åŒ…å« inputs å’Œ class_type
                const keys = Object.keys(json);
                const isPromptFormat = keys.length > 0 && keys.every(key => {
                    const node = json[key];
                    return node && typeof node === 'object' &&
                           (node.inputs !== undefined || node.class_type !== undefined);
                });

                if (isPromptFormat) {
                    return { prompt: json };
                }

                // æƒ…å†µ3: ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ JSON
                // ç‰¹å¾: åŒ…å« nodes æ•°ç»„å’Œ links æ•°ç»„
                if (json.nodes && Array.isArray(json.nodes) && json.links && Array.isArray(json.links)) {
                    const prompt = convertWorkflowToPrompt(json);
                    return { prompt: prompt };
                }

                // æ— æ³•è¯†åˆ«çš„æ ¼å¼
                alert(t('noPromptError'));
                return null;
            } catch (e) {
                console.error('JSON metadata read error:', e);
                return null;
            }
        }

        /**
         * ä» PNG æ–‡ä»¶ä¸­è¯»å–å…ƒæ•°æ®
         * PNG æ ¼å¼: å…ƒæ•°æ®å­˜å‚¨åœ¨ tEXt æˆ– iTXt chunk ä¸­
         * è¿”å›æ ¼å¼: { prompt: "...", workflow: "..." } (å­—ç¬¦ä¸²æ ¼å¼ï¼Œéœ€è¦ parseWorkflow è¿›ä¸€æ­¥è§£æ)
         */
        async function readPngMetadata(data) {
            try {
                const textDecoder = new TextDecoder('utf-8');
                let offset = 8;

                while (offset < data.length - 12) {
                    const length = (data[offset] << 24) | (data[offset + 1] << 16) |
                                   (data[offset + 2] << 8) | data[offset + 3];

                    if (length < 0 || length > data.length - offset - 12) break;

                    const type = textDecoder.decode(data.slice(offset + 4, offset + 8));

                    if (type === 'tEXt' || type === 'iTXt') {
                        const chunkData = data.slice(offset + 8, offset + 8 + length);
                        const text = textDecoder.decode(chunkData);
                        return parsePngText(text);
                    }

                    if (type === 'IEND') break;
                    offset += 12 + length;
                }
            } catch (e) {
                console.error('PNG metadata read error:', e);
            }
            return null;
        }

        /**
         * ä» Latent æ–‡ä»¶ä¸­è¯»å–å…ƒæ•°æ®
         * Latent æ ¼å¼: å‰8å­—èŠ‚æ˜¯å¤´éƒ¨å¤§å°ï¼Œåé¢æ˜¯ JSON æ ¼å¼çš„å¤´éƒ¨æ•°æ®
         * å¤´éƒ¨ä¸­åŒ…å« __metadata__ å­—æ®µï¼Œå…¶ä¸­æœ‰ prompt å’Œ workflow
         * è¿”å›æ ¼å¼: { prompt: {...} } æˆ– { workflow: {...} }
         */
        async function readLatentMetadata(data) {
            try {
                if (data.length < 8) return null;

                const headerSize = Number(
                    new BigUint64Array(data.slice(0, 8).buffer)[0]
                );

                if (headerSize < 0 || headerSize > data.length - 8) {
                    return null;
                }

                const textDecoder = new TextDecoder('utf-8');
                const headerJson = textDecoder.decode(
                    data.slice(8, 8 + headerSize)
                );

                const header = JSON.parse(headerJson);

                if (header.__metadata__) {
                    const metadata = header.__metadata__;

                    // ä¼˜å…ˆè¿”å› prompt (ä¸ parseWorkflow çš„è®¾è®¡ä¸€è‡´)
                    if (metadata.prompt) {
                        try {
                            return { prompt: JSON.parse(metadata.prompt) };
                        } catch {
                            return { prompt: metadata.prompt };
                        }
                    }

                    // å¦‚æœæ²¡æœ‰ promptï¼Œè¿”å› workflow (è™½ç„¶ parseWorkflow ä¸ä¼šä½¿ç”¨å®ƒ)
                    if (metadata.workflow) {
                        try {
                            return { workflow: JSON.parse(metadata.workflow) };
                        } catch {
                            return { workflow: metadata.workflow };
                        }
                    }

                    return metadata;
                }

                return null;
            } catch (e) {
                console.error('Latent metadata read error:', e);
            }
            return null;
        }

        /**
         * è§£æ PNG tEXt chunk çš„æ–‡æœ¬æ•°æ®
         * æ ¼å¼: key\0value\0key\0value...
         * è¿”å›: { key: value, ... }
         */
        function parsePngText(text) {
            const result = {};
            const parts = text.split('\0');
            for (let i = 0; i < parts.length - 1; i += 2) {
                const key = parts[i];
                const value = parts[i + 1];
                if (key && value) {
                    result[key] = value;
                }
            }
            return result;
        }

        /**
         * è§£æå·¥ä½œæµå…ƒæ•°æ®ï¼Œå°† prompt æ ¼å¼è½¬æ¢ä¸ºå†…éƒ¨ä½¿ç”¨çš„æ•°æ®ç»“æ„
         *
         * è®¾è®¡åŸåˆ™ï¼š
         * - åªä½¿ç”¨ prompt æ ¼å¼ (ComfyUI API æ ¼å¼)ï¼Œä¸ä½¿ç”¨ workflow æ ¼å¼ (å‰ç«¯æ ¼å¼)
         * - èŠ‚ç‚¹ä½ç½®ä½¿ç”¨è‡ªåŠ¨æ’åˆ—ç®—æ³•ï¼Œä¸ä½¿ç”¨ workflow ä¸­çš„ä½ç½®ä¿¡æ¯
         * - å­å›¾é€šè¿‡èŠ‚ç‚¹ ID æ ¼å¼ "å­å›¾ID:èŠ‚ç‚¹ID" è¯†åˆ«
         *
         * è¾“å…¥æ ¼å¼ (metadata):
         * - PNG/Latent: { prompt: "{...}" } æˆ– { prompt: {...} }
         * - JSON: { prompt: {...} } (ä¸¤ç§æ ¼å¼å‡å·²æ”¯æŒ)
         *
         * è¾“å‡ºæ ¼å¼ (result):
         * - nodes: { èŠ‚ç‚¹ID: { inputs: {...}, class_type: "...", isSubgraphNode?, subgraphId?, subgraphName? } }
         * - connections: [ { from, fromSlot, to, toSlot } ]
         * - notes: [ { id, text, mode } ]
         * - subgraphs: [ { id, name, nodes: [...] } ]
         */
        function parseWorkflow(metadata) {
            const result = {
                nodes: {},
                connections: [],
                notes: [],
                subgraphs: []
            };

            try {
                // æå– prompt æ•°æ®
                let promptData = null;

                if (metadata.prompt) {
                    promptData = typeof metadata.prompt === 'string' ?
                        JSON.parse(metadata.prompt) : metadata.prompt;
                }

                if (!promptData) {
                    console.error('No prompt data found in metadata');
                    return result;
                }

                // prompt æ ¼å¼ç›´æ¥æ˜¯èŠ‚ç‚¹æ˜ å°„è¡¨: { èŠ‚ç‚¹ID: èŠ‚ç‚¹æ•°æ®, ... }
                result.nodes = promptData;

                // å¤„ç†æ¯ä¸ªèŠ‚ç‚¹
                for (const [nodeId, nodeData] of Object.entries(promptData)) {
                    const inputs = nodeData.inputs || {};
                    const classType = nodeData.class_type;

                    // æå– Note èŠ‚ç‚¹
                    if (classType === 'Note') {
                        result.notes.push({
                            id: nodeId,
                            text: inputs.text || '',
                            mode: inputs.mode
                        });
                    }

                    // æå–è¿æ¥å…³ç³»
                    // prompt ä¸­çš„è¾“å…¥æ ¼å¼: inputs: { å‚æ•°å: [æ¥æºèŠ‚ç‚¹ID, æ¥æºæ§½ä½], ... }
                    for (const [inputName, inputValue] of Object.entries(inputs)) {
                        if (Array.isArray(inputValue) && inputValue.length >= 2) {
                            const [fromNode, fromSlot] = inputValue;
                            result.connections.push({
                                from: fromNode,
                                fromSlot: fromSlot,
                                to: nodeId,
                                toSlot: inputName
                            });
                        }
                    }
                }

                // å¤„ç†å­å›¾
                // å­å›¾èŠ‚ç‚¹ ID æ ¼å¼: "å­å›¾ID:èŠ‚ç‚¹ID" (å¦‚ "18:8" è¡¨ç¤ºå­å›¾18ä¸­çš„èŠ‚ç‚¹8)
                const subgraphMap = new Map();
                for (const [nodeId, nodeData] of Object.entries(promptData)) {
                    if (nodeId.includes(':')) {
                        const [subgraphId, nodeIdPart] = nodeId.split(':');

                        // åˆ›å»ºå­å›¾è®°å½•
                        if (!subgraphMap.has(subgraphId)) {
                            subgraphMap.set(subgraphId, {
                                id: subgraphId,
                                name: `Subgraph ${subgraphId}`,
                                nodes: []
                            });
                        }

                        // æ·»åŠ èŠ‚ç‚¹åˆ°å­å›¾
                        subgraphMap.get(subgraphId).nodes.push({
                            id: nodeIdPart,
                            ...nodeData
                        });

                        // æ ‡è®°èŠ‚ç‚¹ä¸ºå­å›¾èŠ‚ç‚¹ï¼Œç”¨äºåç»­é¢œè‰²åˆ†é…
                        nodeData.isSubgraphNode = true;
                        nodeData.subgraphId = subgraphId;
                        nodeData.subgraphName = `Subgraph ${subgraphId}`;
                    }
                }

                // å°†å­å›¾æ˜ å°„è½¬æ¢ä¸ºæ•°ç»„
                if (subgraphMap.size > 0) {
                    result.subgraphs = Array.from(subgraphMap.values());
                }
            } catch (e) {
                console.error('Parse workflow error:', e);
            }

            return result;
        }

        /**
         * æ¸²æŸ“æ•´ä¸ªå·¥ä½œæµ
         * æµç¨‹ï¼šæ¸…ç©ºç”»å¸ƒ -> è®¡ç®—èŠ‚ç‚¹ä½ç½® -> æ¸²æŸ“èŠ‚ç‚¹ -> æ¸²æŸ“è¿æ¥çº¿
         */
        function renderWorkflow() {
            canvas.innerHTML = '';
            connectionsSvg.innerHTML = '';

            if (!workflowData || !workflowData.nodes) {
                return;
            }

            const nodeCount = Object.keys(workflowData.nodes).length;
            document.getElementById('infoNodeCount').textContent = nodeCount;

            const nodePositions = calculateNodePositions();
            renderNodes(nodePositions);
            updateConnectionPaths();
        }

        /**
         * è®¡ç®—èŠ‚ç‚¹ä½ç½®ï¼ˆè‡ªåŠ¨æ’åˆ—ç®—æ³•ï¼‰
         * ä½¿ç”¨å±‚çº§å¸ƒå±€ç®—æ³•ï¼š
         * 1. æ ¹æ®è¿æ¥å…³ç³»è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å±‚çº§ï¼ˆæ·±åº¦ï¼‰
         * 2. åŒä¸€å±‚çº§çš„èŠ‚ç‚¹æ°´å¹³æ’åˆ—
         * 3. å­å›¾èŠ‚ç‚¹ä¸ä¸»å›¾èŠ‚ç‚¹åˆ†å¼€å¤„ç†å±‚çº§
         * @returns {Object} èŠ‚ç‚¹IDåˆ°ä½ç½®çš„æ˜ å°„ { èŠ‚ç‚¹ID: {x, y} }
         */
        function calculateNodePositions() {
            const positions = {};
            const levels = {};
            const nodeLevel = {};
            const visited = new Set();

            /**
             * é€’å½’è®¡ç®—èŠ‚ç‚¹çš„å±‚çº§ï¼ˆæ·±åº¦ï¼‰
             * å­å›¾èŠ‚ç‚¹çš„å±‚çº§è®¡ç®—ç‹¬ç«‹äºä¸»å›¾èŠ‚ç‚¹
             * @param {string} nodeId - èŠ‚ç‚¹ID
             * @returns {number} èŠ‚ç‚¹çš„å±‚çº§
             */
            function getLevel(nodeId) {
                if (nodeLevel[nodeId] !== undefined) return nodeLevel[nodeId];

                const node = workflowData.nodes[nodeId];
                if (!node) return 0;

                let maxInputLevel = 0;
                for (const input of Object.values(node.inputs || {})) {
                    if (Array.isArray(input) && input[0]) {
                        const inputNodeId = input[0];
                        const inputNode = workflowData.nodes[inputNodeId];

                        if (inputNode) {
                            const inputSubgraphId = inputNode.subgraphId;
                            const currentSubgraphId = node.subgraphId;

                            if (inputSubgraphId !== currentSubgraphId) {
                                maxInputLevel = Math.max(maxInputLevel, getLevel(inputNodeId) + 1);
                            } else {
                                maxInputLevel = Math.max(maxInputLevel, getLevel(inputNodeId));
                            }
                        }
                    }
                }

                nodeLevel[nodeId] = maxInputLevel + 1;
                return nodeLevel[nodeId];
            }

            // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„å±‚çº§
            Object.keys(workflowData.nodes).forEach(id => getLevel(id));

            // æŒ‰å±‚çº§åˆ†ç»„èŠ‚ç‚¹
            const levelNodes = {};
            for (const [id, level] of Object.entries(nodeLevel)) {
                if (!levelNodes[level]) levelNodes[level] = [];
                levelNodes[level].push(id);
            }

            // ä¸ºæ¯ä¸ªèŠ‚ç‚¹è®¡ç®—å…·ä½“ä½ç½®
            for (const [level, nodeIds] of Object.entries(levelNodes)) {
                const levelNum = parseInt(level);
                nodeIds.forEach((nodeId, index) => {
                    const x = 50 + levelNum * 260;  // æ¯å±‚æ°´å¹³é—´è· 260px
                    const y = 50 + index * 180 + (levelNodes[level].length > 1 ? 0 : 50);  // å‚ç›´é—´è· 180px
                    positions[nodeId] = { x, y };
                });
            }

            return positions;
        }

        /**
         * æ¸²æŸ“æ‰€æœ‰èŠ‚ç‚¹
         * ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»º DOM å…ƒç´ ï¼Œè®¾ç½®æ ·å¼ã€ä½ç½®ã€å†…å®¹å’Œäº‹ä»¶å¤„ç†
         * @param {Object} positions - èŠ‚ç‚¹IDåˆ°ä½ç½®çš„æ˜ å°„
         */
        function renderNodes(positions) {
            for (const [nodeId, nodeData] of Object.entries(workflowData.nodes)) {
                // ç¡®å®šèŠ‚ç‚¹ä½ç½®ï¼ˆå­å›¾èŠ‚ç‚¹ä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„ä½ç½®ï¼‰
                const pos = nodeData.isSubgraphNode ?
                    (nodeData.pos ? { x: nodeData.pos[0], y: nodeData.pos[1] } : positions[nodeId] || { x: 100, y: 100 }) :
                    positions[nodeId] || { x: 100, y: 100 };
                const classType = nodeData.class_type;

                // æ„å»ºèŠ‚ç‚¹ CSS ç±»å
                let className = 'node';
                if (classType === 'Note') className += ' note-node';
                if (nodeStates[nodeId]?.collapsed) className += ' collapsed';

                // åˆ›å»ºèŠ‚ç‚¹å…ƒç´ 
                const nodeEl = document.createElement('div');
                nodeEl.className = className;
                nodeEl.style.left = pos.x + 'px';
                nodeEl.style.top = pos.y + 'px';
                nodeEl.dataset.nodeId = nodeId;

                // è®¾ç½®å­å›¾è¾¹æ¡†é¢œè‰²
                const subgraphColor = getSubgraphColor(nodeData.subgraphId);
                if (subgraphColor) {
                    nodeEl.style.borderColor = subgraphColor;
                    nodeEl.style.boxShadow = `0 4px 12px ${subgraphColor}40`;
                }
                const isCollapsed = nodeStates[nodeId]?.collapsed || false;

                let content = '';

                if (classType === 'Note') {
                    const noteData = workflowData.notes.find(n => n.id === nodeId);
                    content = `
                        <div class="node-header" data-node-id="${nodeId}">
                            <span>${classType}</span>
                            <div class="header-actions">
                                <button class="header-btn toggle-btn" data-node="${nodeId}" title="${isCollapsed ? t('expand') : t('toggleCollapse')}">${isCollapsed ? 'â•' : 'â–'}</button>
                            </div>
                        </div>
                        <div class="node-body">
                            <div class="note-content">${escapeHtml(noteData?.text || '')}</div>
                        </div>
                    `;
                } else {
                    const inputs = nodeData.inputs || {};
                    const displayInputs = Object.entries(inputs);

                    const subgraphTag = nodeData.subgraphName ?
                        `<div class="subgraph-tag" data-subgraph-color="${subgraphColor}">${escapeHtml(nodeData.subgraphName)} [${nodeId}]</div>` :
                        '';

                    const nodeIdTag = !nodeData.subgraphName ?
                        `<div class="node-id-tag">[${escapeHtml(nodeId)}]</div>` :
                        '';

                    content = `
                        <div class="node-header" data-node-id="${nodeId}">
                            <span>${classType}</span>
                            <div class="header-actions">
                                <button class="header-btn toggle-btn" data-node="${nodeId}" title="${isCollapsed ? t('expand') : t('toggleCollapse')}">${isCollapsed ? 'â•' : 'â–'}</button>
                            </div>
                        </div>
                        ${subgraphTag}
                        ${nodeIdTag}
                        <div class="node-body">
                            ${displayInputs.map(([key, value]) => `
                                <div class="param-row">
                                    <span class="param-key" title="${escapeHtml(key)}">${escapeHtml(key)}</span>
                                    <span class="param-value" title="${escapeHtml(String(value))}">${escapeHtml(truncateValue(value))}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                nodeEl.innerHTML = content;

                const subgraphTagEl = nodeEl.querySelector('.subgraph-tag');
                if (subgraphTagEl && subgraphColor) {
                    subgraphTagEl.style.background = subgraphColor;
                    subgraphTagEl.style.borderBottomColor = subgraphColor;
                }

                nodeEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectNode(nodeId);
                });

                const header = nodeEl.querySelector('.node-header');
                let isNodeDragging = false;
                let nodeDragStartX, nodeDragStartY, nodeStartX, nodeStartY;

                header.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('header-btn')) return;
                    isNodeDragging = true;
                    nodeDragStartX = e.clientX;
                    nodeDragStartY = e.clientY;
                    nodeStartX = parseFloat(nodeEl.style.left);
                    nodeStartY = parseFloat(nodeEl.style.top);
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (isNodeDragging) {
                        const dx = (e.clientX - nodeDragStartX) / scale;
                        const dy = (e.clientY - nodeDragStartY) / scale;
                        nodeEl.style.left = (nodeStartX + dx) + 'px';
                        nodeEl.style.top = (nodeStartY + dy) + 'px';
                        updateConnectionPaths();
                        updateConnectionHighlight();
                    }
                });

                document.addEventListener('mouseup', () => {
                    isNodeDragging = false;
                });

                nodeEl.querySelectorAll('.header-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const nodeId = btn.dataset.node;
                        nodeStates[nodeId] = nodeStates[nodeId] || {};
                        nodeStates[nodeId].collapsed = !nodeStates[nodeId].collapsed;
                        renderWorkflow();
                        setTimeout(updateTransform, 0);
                    });
                });

                // ä¸ºå‚æ•°å€¼æ·»åŠ æ»šè½®äº‹ä»¶ï¼Œå®ç°æ‚¬åœæ—¶æ»šåŠ¨
                nodeEl.querySelectorAll('.param-value').forEach(paramValue => {
                    paramValue.addEventListener('wheel', (e) => {
                        // æ£€æŸ¥å†…å®¹æ˜¯å¦è¶…å‡ºå¯è§†åŒºåŸŸ
                        const canScrollDown = paramValue.scrollHeight > paramValue.clientHeight;
                        const canScrollUp = paramValue.scrollTop > 0;
                        const canScroll = canScrollDown || canScrollUp;

                        if (canScroll) {
                            // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢ç”»å¸ƒç¼©æ”¾
                            e.stopPropagation();

                            // æ£€æŸ¥æ˜¯å¦æ»šåŠ¨åˆ°è¾¹ç•Œ
                            const isAtTop = paramValue.scrollTop <= 0 && e.deltaY < 0;
                            const isAtBottom = paramValue.scrollTop + paramValue.clientHeight >= paramValue.scrollHeight && e.deltaY > 0;

                            // åªæœ‰åœ¨æ²¡æœ‰åˆ°è¾¾è¾¹ç•Œæ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸º
                            if (!isAtTop && !isAtBottom) {
                                e.preventDefault();
                                paramValue.scrollTop += e.deltaY;
                            }
                        }
                    }, { passive: false });
                });

                // ä¸º Note å†…å®¹æ·»åŠ æ»šè½®äº‹ä»¶
                nodeEl.querySelectorAll('.note-content').forEach(noteContent => {
                    noteContent.addEventListener('wheel', (e) => {
                        // æ£€æŸ¥å†…å®¹æ˜¯å¦è¶…å‡ºå¯è§†åŒºåŸŸ
                        const canScrollDown = noteContent.scrollHeight > noteContent.clientHeight;
                        const canScrollUp = noteContent.scrollTop > 0;
                        const canScroll = canScrollDown || canScrollUp;

                        if (canScroll) {
                            // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢ç”»å¸ƒç¼©æ”¾
                            e.stopPropagation();

                            // æ£€æŸ¥æ˜¯å¦æ»šåŠ¨åˆ°è¾¹ç•Œ
                            const isAtTop = noteContent.scrollTop <= 0 && e.deltaY < 0;
                            const isAtBottom = noteContent.scrollTop + noteContent.clientHeight >= noteContent.scrollHeight && e.deltaY > 0;

                            // åªæœ‰åœ¨æ²¡æœ‰åˆ°è¾¾è¾¹ç•Œæ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸º
                            if (!isAtTop && !isAtBottom) {
                                e.preventDefault();
                                noteContent.scrollTop += e.deltaY;
                            }
                        }
                    }, { passive: false });
                });

                canvas.appendChild(nodeEl);
            }
        }

        /**
         * æˆªæ–­è¿‡é•¿çš„å‚æ•°å€¼ç”¨äºæ˜¾ç¤º
         * @param {*} value - å‚æ•°å€¼
         * @returns {string} æˆªæ–­åçš„å­—ç¬¦ä¸²
         */
        function truncateValue(value) {
            if (Array.isArray(value)) {
                if (value.length === 2 && typeof value[0] === 'string') {
                    return `[${value[0]}]`;
                }
                return `[${value.join(', ')}]`;
            }
            return String(value);
        }

        /**
         * æ›´æ–°è¿æ¥çº¿çš„ SVG è·¯å¾„
         * æ ¹æ®èŠ‚ç‚¹ä½ç½®è®¡ç®—è´å¡å°”æ›²çº¿è·¯å¾„
         */
        function updateConnectionPaths() {
            let svgContent = '';

            for (const conn of workflowData.connections) {
                const fromNodeEl = document.querySelector(`[data-node-id="${conn.from}"]`);
                const toNodeEl = document.querySelector(`[data-node-id="${conn.to}"]`);

                if (!fromNodeEl || !toNodeEl) continue;

                // è·å–èŠ‚ç‚¹ä½ç½®å’Œå°ºå¯¸
                const fromRect = {
                    x: parseFloat(fromNodeEl.style.left),
                    y: parseFloat(fromNodeEl.style.top),
                    width: fromNodeEl.offsetWidth,
                    height: fromNodeEl.offsetHeight
                };

                const toRect = {
                    x: parseFloat(toNodeEl.style.left),
                    y: parseFloat(toNodeEl.style.top),
                    width: toNodeEl.offsetWidth,
                    height: toNodeEl.offsetHeight
                };

                // è®¡ç®—è¿æ¥ç‚¹åæ ‡ï¼ˆä»å³ä¾§ä¸­ç‚¹å‡ºå‘ï¼Œåˆ°å·¦ä¾§ä¸­ç‚¹ï¼‰
                const x1 = fromRect.x + fromRect.width;
                const y1 = fromRect.y + fromRect.height / 2;
                const x2 = toRect.x;
                const y2 = toRect.y + toRect.height / 2;
                const midX = (x1 + x2) / 2;

                const path = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                svgContent += `<path class="connection-line" d="${path}" data-from="${conn.from}" data-to="${conn.to}" />`;
            }

            connectionsSvg.innerHTML = svgContent;

            const wrapperRect = canvasWrapper.getBoundingClientRect();
            connectionsSvg.setAttribute('viewBox', `0 0 ${wrapperRect.width} ${wrapperRect.height}`);
            connectionsSvg.style.width = wrapperRect.width + 'px';
            connectionsSvg.style.height = wrapperRect.height + 'px';

            updateConnectionHighlight();
        }

        /**
         * è½¬ä¹‰ HTML ç‰¹æ®Šå­—ç¬¦ï¼Œé˜²æ­¢ XSS æ”»å‡»
         * @param {string} text - åŸå§‹æ–‡æœ¬
         * @returns {string} è½¬ä¹‰åçš„ HTML å®‰å…¨æ–‡æœ¬
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * é€‰ä¸­æŒ‡å®šèŠ‚ç‚¹
         * æ·»åŠ é€‰ä¸­æ ·å¼å’Œå‘å…‰æ•ˆæœï¼Œå¹¶é«˜äº®ç›¸å…³è¿æ¥çº¿
         * @param {string} nodeId - èŠ‚ç‚¹ID
         */
        function selectNode(nodeId) {
            // æ¸…é™¤æ‰€æœ‰èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('selected');
                node.style.boxShadow = '';
            });

            const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.classList.add('selected');
                selectedNodeId = nodeId;

                // æ ¹æ®å­å›¾IDè·å–å‘å…‰é¢œè‰²
                const nodeData = workflowData ? Object.entries(workflowData.nodes || {}).find(([id]) => id === nodeId)?.[1] : null;
                const subgraphId = nodeData?.subgraphId;
                const glowColor = subgraphId ? getSubgraphColor(subgraphId) : '#cccccc';
                const rgb = hexToRgb(glowColor);

                // è®¾ç½®å¤šå±‚å‘å…‰æ•ˆæœ
                nodeEl.style.boxShadow = `0 0 20px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6), 0 0 40px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4), 0 0 0 2px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3) !important`;

                updateConnectionHighlight();
            }
        }

        /**
         * å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º RGB å¯¹è±¡
         * @param {string} hex - åå…­è¿›åˆ¶é¢œè‰²å€¼ï¼ˆå¦‚ #ff69b4ï¼‰
         * @returns {Object} åŒ…å« r, g, b å±æ€§çš„å¯¹è±¡
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 200, g: 200, b: 200 };
        }

        /**
         * å–æ¶ˆæ‰€æœ‰èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€
         * æ¸…é™¤é€‰ä¸­æ ·å¼ã€å‘å…‰æ•ˆæœå’Œè¿æ¥çº¿é«˜äº®
         */
        function deselectAll() {
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('selected');
                node.style.boxShadow = '';
            });
            document.querySelectorAll('.connection-line-flow').forEach(line => {
                line.remove();
            });
            document.querySelectorAll('.connection-line').forEach(line => {
                delete line.dataset.hasFlow;
            });
            selectedNodeId = null;
        }

        /**
         * æ›´æ–°è¿æ¥çº¿çš„é«˜äº®çŠ¶æ€
         * å½“èŠ‚ç‚¹è¢«é€‰ä¸­æ—¶ï¼Œé«˜äº®ä¸è¯¥èŠ‚ç‚¹ç›¸å…³çš„è¿æ¥çº¿
         */
        function updateConnectionHighlight() {
            if (!selectedNodeId) {
                document.querySelectorAll('.connection-line-flow').forEach(line => {
                    line.remove();
                });
                document.querySelectorAll('.connection-line').forEach(line => {
                    delete line.dataset.hasFlow;
                });
                return;
            }

            document.querySelectorAll('.connection-line').forEach(line => {
                const fromNodeId = line.dataset.from;
                const toNodeId = line.dataset.to;

                // å¦‚æœè¿æ¥çº¿ä¸é€‰ä¸­èŠ‚ç‚¹ç›¸å…³ï¼Œæ·»åŠ æµåŠ¨æ•ˆæœ
                if (fromNodeId === selectedNodeId || toNodeId === selectedNodeId) {
                    if (!line.dataset.hasFlow) {
                        const d = line.getAttribute('d');
                        const flowLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        flowLine.setAttribute('d', d);
                        flowLine.setAttribute('class', 'connection-line-flow');
                        flowLine.setAttribute('data-from', fromNodeId);
                        flowLine.setAttribute('data-to', toNodeId);
                        connectionsSvg.appendChild(flowLine);
                        line.dataset.hasFlow = 'true';
                    }
                } else {
                    if (line.dataset.hasFlow === 'true') {
                        line.dataset.hasFlow = 'false';
                        const flowLine = connectionsSvg.querySelector(`.connection-line-flow[data-from="${fromNodeId}"][data-to="${toNodeId}"]`);
                        if (flowLine) {
                            flowLine.remove();
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
