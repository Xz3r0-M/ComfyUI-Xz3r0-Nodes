<!--
    XMetadataWorkflow - ComfyUI å·¥ä½œæµå…ƒæ•°æ®æŸ¥çœ‹å™¨
    ================================================
    ç‰ˆæœ¬: 1.2.2
    æ›´æ–°æ—¥æœŸ: 2026-02-25

    åŠŸèƒ½æ¦‚è¿°:
    ---------
    ä¸€ä¸ªç‹¬ç«‹çš„ç½‘é¡µå·¥å…·ï¼Œç”¨äºæŸ¥çœ‹å’Œåˆ†æ ComfyUI å·¥ä½œæµå…ƒæ•°æ®ï¼Œæ— éœ€å¯åŠ¨ ComfyUI å³å¯é¢„è§ˆå·¥ä½œæµç»“æ„ã€‚

    æ”¯æŒçš„æ–‡ä»¶æ ¼å¼:
    ---------------
    - PNG å›¾ç‰‡ (.png) - åŒ…å«å·¥ä½œæµå…ƒæ•°æ®çš„ç”Ÿæˆå›¾ç‰‡
    - Latent æ½œç©ºé—´æ–‡ä»¶ (.latent) - åŒ…å« __metadata__ çš„æ½œç©ºé—´æ–‡ä»¶
    - JSON å·¥ä½œæµæ–‡ä»¶ (.json) - æ”¯æŒä¸‰ç§æ ¼å¼ï¼š
        * XWorkflowSave ç”Ÿæˆçš„æ ¼å¼ (åŒ…å« prompt å­—æ®µï¼Œæ”¯æŒ merge æ¨¡å¼)
        * ComfyUI ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ (ç›´æ¥æ˜¯ prompt æ•°æ®)
        * ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ (åŒ…å« nodes å’Œ links æ•°ç»„)

    æ ¸å¿ƒåŠŸèƒ½:
    ---------
    1. æ–‡ä»¶è§£æ:
       - PNG: ä» tEXt/iTXt chunk è¯»å– prompt/workflow å…ƒæ•°æ®
       - Latent: ä»æ–‡ä»¶å¤´éƒ¨ JSON è¯»å– __metadata__
       - JSON: æ™ºèƒ½è¯†åˆ«å¹¶è§£æä¸‰ç§å·¥ä½œæµæ ¼å¼
       - Merge æ¨¡å¼: è‡ªåŠ¨åˆå¹¶ prompt å’Œ full_workflow æ•°æ®ï¼Œä¿ç•™æ‰§è¡Œç»“æœå’Œå®Œæ•´ç»“æ„

    2. å·¥ä½œæµå¯è§†åŒ–:
       - è‡ªåŠ¨å±‚çº§å¸ƒå±€ç®—æ³•æ’åˆ—èŠ‚ç‚¹
       - ä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„èŠ‚ç‚¹ä½ç½®ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
       - æ˜¾ç¤ºèŠ‚ç‚¹ç±»å‹ã€å‚æ•°å’Œè¿æ¥å…³ç³»
       - å­å›¾è‡ªåŠ¨è¯†åˆ«å’Œé¢œè‰²æ ‡è®° (IDæ ¼å¼: "å­å›¾ID:èŠ‚ç‚¹ID")
       - é€‰ä¸­èŠ‚ç‚¹å‘å…‰æ•ˆæœï¼ˆåŸºäºå­å›¾é¢œè‰²ï¼‰
       - è¿æ¥ç‚¹åœ†ç‚¹æ˜¾ç¤ºï¼ˆè¾“å…¥åœ¨å·¦ä¾§ï¼Œè¾“å‡ºåœ¨å³ä¾§ï¼‰
       - æ”¯æŒç¼©æ”¾ã€å¹³ç§»ã€è‡ªé€‚åº”è§†å›¾

    3. äº¤äº’åŠŸèƒ½:
       - æŠ˜å /å±•å¼€èŠ‚ç‚¹å‚æ•°
       - å•å‡»é€‰ä¸­èŠ‚ç‚¹ï¼Œé«˜äº®ç›¸å…³è¿æ¥ï¼ˆå¸¦æµåŠ¨åŠ¨ç”»æ•ˆæœï¼‰
       - å¤šé€‰èŠ‚ç‚¹: Ctrl+ç‚¹å‡» æˆ– æ¡†é€‰(Ctrl+æ‹–æ‹½)
       - èŠ‚ç‚¹æ‹–æ‹½é‡æ–°å¸ƒå±€ï¼ˆæ”¯æŒå¤šèŠ‚ç‚¹åŒæ—¶æ‹–æ‹½ï¼‰
       - èŠ‚ç‚¹å¤§å°è°ƒæ•´: 8ä¸ªæ–¹å‘æ‹‰ä¼¸æ§åˆ¶ç‚¹ï¼ˆè§’+è¾¹ï¼‰
       - ç”»å¸ƒå¹³ç§»: é¼ æ ‡ç©ºç™½å¤„æ‹–æ‹½ æˆ– ä¸­é”®æ‹–æ‹½
       - æ»šè½®ç¼©æ”¾ï¼Œä»¥é¼ æ ‡ä½ç½®ä¸ºä¸­å¿ƒ
       - å¤åˆ¶èŠ‚ç‚¹åç§°: ç‚¹å‡»æ ‡é¢˜æ å·¦ä¾§ ğŸ“‹ æŒ‰é’®ï¼Œå¿«é€Ÿå¤åˆ¶èŠ‚ç‚¹ç±»å‹åç§°åˆ°å‰ªè´´æ¿

    4. ç•Œé¢ç‰¹æ€§:
       - æ”¯æŒæš—é»‘/äº®è‰²ä¸»é¢˜åˆ‡æ¢ï¼ˆæœ¬åœ°å­˜å‚¨è®°å¿†ï¼‰
       - æ”¯æŒä¸­è‹±æ–‡è¯­è¨€åˆ‡æ¢ï¼ˆæœ¬åœ°å­˜å‚¨è®°å¿†ï¼‰
       - ä¾§è¾¹æ æŠ˜å /å±•å¼€åŠŸèƒ½ï¼ˆé»˜è®¤å±•å¼€ï¼Œä¸æŒä¹…åŒ–ï¼‰
       - æ–‡ä»¶ä¿¡æ¯é¢„è§ˆé¢æ¿ï¼ˆå›¾ç‰‡é¢„è§ˆã€Latentæ ‡è¯†ï¼‰
       - ç¼©æ”¾æ§åˆ¶: æŒ‰é’®ã€è¾“å…¥æ¡†ç²¾ç¡®è®¾ç½®ã€é€‚åº”çª—å£
       - è™šæ‹Ÿæ»šåŠ¨: é•¿æ–‡æœ¬å‚æ•°ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨ä¼˜åŒ–æ€§èƒ½
       - é•¿æ–‡æœ¬æ“ä½œ: ä¸€é”®å¤åˆ¶ã€ä¸‹è½½ä¸ºæ–‡ä»¶
       - Toast æç¤º: æ“ä½œåé¦ˆï¼ˆå¤åˆ¶æˆåŠŸã€ä¸‹è½½å¼€å§‹ç­‰ï¼‰

    5. ç‰¹æ®ŠèŠ‚ç‚¹å¤„ç†:
       - XWorkflowSave èŠ‚ç‚¹è¯†åˆ«å’Œæ ‡è®°
       - Note/MarkdownNote èŠ‚ç‚¹ç‰¹æ®Šæ˜¾ç¤º
       - Bypass èŠ‚ç‚¹çŠ¶æ€æ˜¾ç¤º

    æ•°æ®æ ¼å¼è¯´æ˜:
    -------------
    - å†…éƒ¨ç»Ÿä¸€ä½¿ç”¨ prompt æ ¼å¼ (ComfyUI API æ ¼å¼)
    - å®Œæ•´ Workflow æ ¼å¼ä¼šè‡ªåŠ¨è½¬æ¢ä¸º Prompt API æ ¼å¼
    - Merge æ¨¡å¼: åˆå¹¶ promptï¼ˆæ‰§è¡Œç»“æœï¼‰å’Œ full_workflowï¼ˆå®Œæ•´ç»“æ„ï¼‰æ•°æ®
    - èŠ‚ç‚¹ä½ç½®ä¼˜å…ˆä½¿ç”¨ workflow ä¸­ä¿å­˜çš„åŸå§‹ä½ç½®
    - å­å›¾é€šè¿‡èŠ‚ç‚¹ ID ä¸­çš„ ":" è¯†åˆ« (å¦‚ "18:8" è¡¨ç¤ºå­å›¾18ä¸­çš„èŠ‚ç‚¹8)

    æŠ€æœ¯æ ˆ:
    -------
    - çº¯å‰ç«¯å®ç°ï¼Œæ— éœ€åç«¯æœåŠ¡
    - åŸç”Ÿ JavaScript (ES6+)
    - SVG ç»˜åˆ¶è¿æ¥çº¿å’Œè¿æ¥ç‚¹
    - CSS3 åŠ¨ç”»æ•ˆæœï¼ˆæµåŠ¨çº¿æ¡ã€å‘å…‰æ•ˆæœï¼‰
    - ResizeObserver ç›‘å¬èŠ‚ç‚¹å°ºå¯¸å˜åŒ–

    æ€§èƒ½ä¼˜åŒ–:
    ---------
    - è™šæ‹Ÿæ»šåŠ¨: é•¿æ–‡æœ¬å†…å®¹åˆ†æ®µæ¸²æŸ“
    - ResizeObserver: åŠæ—¶æ¸…ç†é˜²æ­¢å†…å­˜æ³„æ¼
    - Object URL ç®¡ç†: åŠæ—¶é‡Šæ”¾é¢„è§ˆå›¾ç‰‡å†…å­˜

    ä½œè€…: Xz3r0
    é¡¹ç›®: ComfyUI-Xz3r0-Nodes
    è®¸å¯è¯: MIT License
-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMetadataWorkflow</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252525;
            --bg-tertiary: #2a2a2a;
            --bg-canvas: #181818;
            --bg-preview: #1a1a1a;
            --bg-node: #333;
            --bg-node-header: #3d3d3d;
            --bg-param-key: #2a2a2a;
            --bg-param-value: #252525;
            --bg-note: #2a2525;
            --bg-btn: #333;
            --bg-btn-hover: #444;
            --bg-latent-badge: #3d4d5d;

            --border-primary: #3d3d3d;
            --border-secondary: #444;
            --border-tertiary: #555;
            --border-param: #3a3a3a;

            --text-primary: #fff;
            --text-secondary: #ddd;
            --text-tertiary: #ddd;
            --text-muted: #ddd;
            --text-dim: #ddd;
            --text-placeholder: #ddd;
            --text-hint: #ddd;

            --accent: #ff69b4;
            --accent-hover: rgba(123, 104, 238, 0.05);

            --connection-line: #555;
            --resize-handle: #555;

            --shadow-node: rgba(0, 0, 0, 0.3);
            --shadow-node-hover: rgba(0, 0, 0, 0.4);
            --shadow-selected: rgba(200, 200, 200, 0.6);

            --dot-pattern: #2a2a2a;

            --header-btn-bg: rgba(255, 255, 255, 0.1);
            --header-btn-bg-hover: rgba(255, 255, 255, 0.2);
        }

        [data-theme="light"] {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #ffffff;
            --bg-canvas: #e0e0e0;
            --bg-preview: #e0e0e0;
            --bg-node: #ffffff;
            --bg-node-header: #ffffff;
            --bg-param-key: #e0e0e0;
            --bg-param-value: #e0e0e0;
            --bg-note: #f8f0f0;
            --bg-btn: #ffffff;
            --bg-btn-hover: #e0e0e0;
            --bg-latent-badge: #e0e8f0;

            --border-primary: #ddd;
            --border-secondary: #ccc;
            --border-tertiary: #bbb;
            --border-param: #e0e0e0;

            --text-primary: #1a1a1a;
            --text-secondary: #1a1a1a;
            --text-tertiary: #1a1a1a;
            --text-muted: #1a1a1a;
            --text-dim: #1a1a1a;
            --text-placeholder: #1a1a1a;
            --text-hint: #1a1a1a;

            --accent: #ff69b4;
            --accent-hover: rgba(255, 105, 180, 0.1);

            --connection-line: #aaa;
            --resize-handle: #bbb;

            --shadow-node: rgba(0, 0, 0, 0.1);
            --shadow-node-hover: rgba(0, 0, 0, 0.15);
            --shadow-selected: rgba(255, 105, 180, 0.4);

            --dot-pattern: #bbbbbb;

            --header-btn-bg: rgba(0, 0, 0, 0.05);
            --header-btn-bg-hover: rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-secondary);
            height: 100vh;
            overflow: hidden;
        }

        .file-input {
            display: none;
        }

        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            transition: width 0.3s ease, min-width 0.3s ease, opacity 0.3s ease;
        }

        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            opacity: 0;
            border-right: none;
        }

        .sidebar-toggle {
            position: absolute;
            left: 280px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 60px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-left: none;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: left 0.3s ease, background 0.2s;
            padding: 0;
            color: var(--text-muted);
            font-size: 10px;
        }

        .sidebar-toggle:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-secondary);
        }

        .sidebar-toggle .toggle-icon {
            transition: transform 0.3s ease;
        }

        .sidebar.collapsed + .sidebar-toggle {
            left: 0;
        }

        .sidebar.collapsed + .sidebar-toggle .toggle-icon {
            transform: rotate(180deg);
        }

        .sidebar-header {
            padding: 12px 15px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .language-switch {
            display: flex;
            padding: 10px 15px;
            border-top: 1px solid var(--border-primary);
            gap: 8px;
            justify-content: center;
        }

        .lang-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-muted);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .lang-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        .lang-btn.active {
            background: var(--bg-tertiary);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .theme-switch {
            display: flex;
            padding: 10px 15px;
            border-top: 1px solid var(--border-primary);
            gap: 8px;
            justify-content: center;
        }

        .theme-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .theme-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .theme-btn.active {
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .theme-btn[data-theme="dark"]:not(.active) {
            background: #1a1a1a;
            border-color: #1a1a1a;
            color: #fff;
        }

        .theme-btn[data-theme="dark"].active {
            background: #1a1a1a;
            border-color: var(--accent);
            color: var(--accent);
        }

        .theme-btn[data-theme="light"]:not(.active) {
            background: #ffffff;
            border-color: #ffffff;
            color: #1a1a1a;
        }

        .theme-btn[data-theme="light"].active {
            background: #ffffff;
            border-color: var(--accent);
            color: var(--accent);
        }

        .file-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 15px;
        }

        .file-area .file-input {
            display: none;
        }

        .file-area .file-preview {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-preview);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 1px solid var(--border-primary);
        }

        .file-area .file-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .file-area .file-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-placeholder);
            cursor: pointer;
            padding: 20px;
            width: 100%;
            height: 100%;
            border: 2px dashed transparent;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .file-area .file-placeholder:hover {
            border-color: var(--accent);
            background: var(--accent-hover);
        }

        .file-area .file-placeholder .icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .file-area .file-placeholder span {
            font-size: 12px;
            white-space: pre-line;
            text-align: center;
        }

        .file-area .file-placeholder .hint {
            font-size: 10px;
            color: var(--text-hint);
            margin-top: 4px;
        }

        .file-area .file-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-area .file-info-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 11px;
        }

        .file-area .file-info-item .label {
            color: var(--text-dim);
            flex-shrink: 0;
        }

        .file-area .file-info-item .value {
            color: var(--text-tertiary);
            text-align: right;
            word-break: break-all;
            margin-left: 10px;
        }

        .file-area .file-info-item .value.latent-badge {
            display: inline-block;
            background: var(--bg-latent-badge);
            color: var(--accent);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-canvas);
            background-image:
                radial-gradient(circle, var(--dot-pattern) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #canvas-wrapper {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .svg-connections {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .connection-line {
            stroke: var(--connection-line);
            stroke-width: 2;
            fill: none;
            transition: all 0.3s ease;
        }

        .connection-line.highlight {
            stroke: var(--accent);
            stroke-width: 3;
            animation: line-flow 1.5s linear infinite;
        }

        .connection-line-base {
            stroke: var(--connection-line);
            stroke-width: 2;
            fill: none;
        }

        .connection-line-flow {
            stroke: var(--accent);
            stroke-width: 3;
            fill: none;
            animation: line-flow 1.5s linear infinite;
        }

        /* è¿æ¥ç‚¹åœ†ç‚¹æ ·å¼ */
        .connection-dot {
            fill: var(--bg-node);
            stroke: var(--connection-line);
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .connection-dot.highlight {
            fill: var(--accent);
            stroke: var(--accent);
            stroke-width: 2;
        }

        @keyframes line-flow {
            0% {
                stroke-dasharray: 10, 20;
                stroke-dashoffset: 0;
            }
            100% {
                stroke-dasharray: 10, 20;
                stroke-dashoffset: -30;
            }
        }

        .node {
            position: absolute;
            background: var(--bg-node);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            min-width: 180px;
            min-height: 60px;
            width: 220px;
            z-index: 10;
            box-shadow: 0 4px 12px var(--shadow-node);
            transition: box-shadow 0.1s, border-color 0.3s;
            overflow: hidden;
        }

        /* èŠ‚ç‚¹æ‹‰ä¼¸æ§åˆ¶ç‚¹ */
        .resize-handle {
            position: absolute;
            z-index: 100;
            background: transparent;
        }

        .resize-handle:hover,
        .resize-handle.active {
            background: var(--accent);
        }

        /* è§’æ§åˆ¶ç‚¹ - 8x8px */
        .resize-handle.nw,
        .resize-handle.ne,
        .resize-handle.sw,
        .resize-handle.se {
            width: 10px;
            height: 10px;
        }

        .resize-handle.nw {
            top: -5px;
            left: -5px;
            cursor: nw-resize;
            border-radius: 0 0 4px 0;
        }

        .resize-handle.ne {
            top: -5px;
            right: -5px;
            cursor: ne-resize;
            border-radius: 0 0 0 4px;
        }

        .resize-handle.sw {
            bottom: -5px;
            left: -5px;
            cursor: sw-resize;
            border-radius: 0 4px 0 0;
        }

        .resize-handle.se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
            border-radius: 4px 0 0 0;
        }

        /* è¾¹æ§åˆ¶ç‚¹ */
        .resize-handle.n,
        .resize-handle.s {
            width: calc(100% - 20px);
            height: 6px;
            left: 10px;
        }

        .resize-handle.n {
            top: -3px;
            cursor: n-resize;
            border-radius: 0 0 3px 3px;
        }

        .resize-handle.s {
            bottom: -3px;
            cursor: s-resize;
            border-radius: 3px 3px 0 0;
        }

        .resize-handle.w,
        .resize-handle.e {
            width: 6px;
            height: calc(100% - 20px);
            top: 10px;
        }

        .resize-handle.w {
            left: -3px;
            cursor: w-resize;
            border-radius: 0 3px 3px 0;
        }

        .resize-handle.e {
            right: -3px;
            cursor: e-resize;
            border-radius: 3px 0 0 3px;
        }

        /* èŠ‚ç‚¹æ­£åœ¨æ‹‰ä¼¸æ—¶çš„æ ·å¼ */
        .node.resizing {
            user-select: none;
            -webkit-user-select: none;
        }

        .node.resizing .node-header {
            cursor: default !important;
        }

        .node:hover {
            box-shadow: 0 6px 16px var(--shadow-node-hover);
        }

        .node.selected {
            border-color: var(--border-tertiary) !important;
            box-shadow: 0 0 20px var(--shadow-selected), 0 0 40px var(--shadow-selected), 0 0 0 2px var(--shadow-selected) !important;
            animation: node-glow 2s ease-in-out infinite alternate;
        }

        @keyframes node-glow {
            0% {
                box-shadow: 0 0 20px var(--shadow-selected), 0 0 40px var(--shadow-selected), 0 0 0 2px var(--shadow-selected);
            }
            100% {
                box-shadow: 0 0 30px var(--shadow-selected), 0 0 60px var(--shadow-selected), 0 0 0 3px var(--shadow-selected);
            }
        }

        .node.collapsed .node-body {
            display: none;
        }

        .subgraph-tag {
            font-size: 9px;
            color: #fff;
            padding: 3px 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid var(--border-primary);
        }

        .node-id-tag {
            font-size: 9px;
            color: var(--text-muted);
            padding: 3px 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
        }

        .node-header {
            padding: 6px 10px;
            background: var(--bg-node-header);
            border-radius: 7px 7px 0 0;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: default;
            user-select: none;
            -webkit-user-select: none;
            border-bottom: 1px solid var(--border-tertiary);
        }

        .node-header-text {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .node-header.dragging {
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent);
            background: rgba(255, 105, 180, 0.1);
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .node.multi-selected {
            border-color: var(--accent) !important;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.5), 0 0 30px rgba(255, 105, 180, 0.3) !important;
        }

        .header-actions {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }

        .header-btn {
            width: 18px;
            height: 18px;
            border: none;
            background: var(--header-btn-bg);
            color: var(--text-tertiary);
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.1s;
        }

        .header-btn:hover {
            background: var(--header-btn-bg-hover);
            color: var(--text-primary);
        }

        .node-body {
            padding: 8px 10px;
            font-size: 10px;
            color: var(--text-tertiary);
            max-height: none;
            overflow-y: visible;
        }

        .node-body::-webkit-scrollbar {
            width: 4px;
        }

        .node-body::-webkit-scrollbar-track {
            background: transparent;
        }

        .node-body::-webkit-scrollbar-thumb {
            background: var(--border-tertiary);
            border-radius: 2px;
        }

        .param-row {
            display: flex;
            padding: 2px 0;
            gap: 8px;
            flex-wrap: wrap;
            border-bottom: 1px solid var(--border-param);
        }

        .param-key {
            color: var(--text-muted);
            flex-shrink: 0;
            overflow: visible;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: var(--bg-param-key);
            padding: 1px 4px;
            border-radius: 2px;
            text-align: left;
        }

        .param-value {
            color: var(--text-secondary);
            word-break: break-all;
            text-align: left;
            flex: 1;
            overflow: auto;
            text-overflow: clip;
            white-space: pre-wrap;
            word-wrap: break-word;
            background: var(--bg-param-value);
            padding: 1px 4px;
            border-radius: 2px;
            max-height: 100px;
        }

        .param-value::-webkit-scrollbar {
            width: 3px;
            height: 3px;
        }

        .param-value::-webkit-scrollbar-track {
            background: transparent;
        }

        .param-value::-webkit-scrollbar-thumb {
            background: var(--border-tertiary);
            border-radius: 2px;
        }

        .note-node .node-body {
            padding: 8px;
        }

        .note-content {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: pre-wrap;
            background: var(--bg-note);
            padding: 8px;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
        }

        .note-content .long-text-wrapper {
            background: transparent;
            border: none;
            margin: -8px;
        }

        .note-content .long-text-header {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px 4px 0 0;
        }

        .note-content .virtual-scroll-container {
            padding: 0 8px;
        }

        .zoom-controls {
            position: fixed;
            bottom: 10px;
            right: 20px;
            display: flex;
            gap: 4px;
            z-index: 100;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-secondary);
            background: var(--bg-btn);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .zoom-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-btn);
        }

        .zoom-level {
            width: 50px;
            padding: 0 5px;
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            background: var(--bg-btn);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            text-align: center;
        }

        .zoom-level:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* è™šæ‹Ÿæ»šåŠ¨æ ·å¼ */
        .long-text-wrapper {
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            background: var(--bg-param-value);
            overflow: hidden;
            flex: 1;
            min-width: 0;
        }

        .long-text-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 6px;
            background: var(--bg-param-key);
            border-bottom: 1px solid var(--border-tertiary);
            font-size: 10px;
        }

        .long-text-info {
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .long-text-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .text-action-btn {
            font-size: 9px;
            padding: 1px 4px;
            background: var(--bg-btn);
            border: 1px solid var(--border-tertiary);
            border-radius: 2px;
            cursor: pointer;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .text-action-btn:hover {
            background: var(--bg-btn-hover);
        }

        .virtual-scroll-container {
            background: var(--bg-param-value);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 11px;
            line-height: 16px;
            overflow: auto;
        }

        .virtual-scroll-line {
            padding: 0 8px;
            white-space: pre;
            height: 16px;
            line-height: 16px;
            min-width: fit-content;
        }

        .virtual-scroll-line:hover {
            background: var(--bg-btn-hover);
        }

        .param-value-short {
            padding: 4px 8px;
            white-space: pre-wrap;
            word-break: break-all;
            overflow: auto;
            max-height: 100px;
        }

        .long-param {
            flex-direction: row;
            align-items: flex-start;
        }

        .long-param .param-key {
            margin-bottom: 0;
            flex-shrink: 0;
            margin-right: 8px;
            margin-top: 4px;
        }

        .param-value-container {
            flex: 1;
            min-width: 0;
        }

        /* Toast æç¤º */
        .toast-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            z-index: 10000;
            font-size: 14px;
            animation: fadeInOut 2s ease;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            90% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">XMetadataWorkflow</div>
            <div class="file-area" id="fileArea">
                <input type="file" id="fileInput" class="file-input" accept=".png,.latent,.json">
                <div class="file-preview" id="filePreview">
                    <div class="file-placeholder" id="filePlaceholder">
                        <span class="icon">ğŸ“</span>
                        <span data-i18n="DroporSelect">æ‹–æ”¾æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</span>
                        <span class="hint" data-i18n="filetip"></span>
                    </div>
                </div>
                <div class="file-info" id="fileInfo">
                    <div class="file-info-item">
                        <span class="label" data-i18n="filename">æ–‡ä»¶å</span>
                        <span class="value" id="infoFilename">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="filetype">ç±»å‹</span>
                        <span class="value" id="infoType">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="filesize">å¤§å°</span>
                        <span class="value" id="infoSize">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="resolution">åˆ†è¾¨ç‡</span>
                        <span class="value" id="infoResolution">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="modified">ä¿®æ”¹æ—¥æœŸ</span>
                        <span class="value" id="infoModified">-</span>
                    </div>
                    <div class="file-info-item">
                        <span class="label" data-i18n="nodes">èŠ‚ç‚¹</span>
                        <span class="value" id="infoNodeCount">-</span>
                    </div>
                </div>
            </div>
            <div class="language-switch" id="languageSwitch">
                <button class="lang-btn" data-lang="zh" data-i18n="langZh">ä¸­æ–‡</button>
                <button class="lang-btn" data-lang="en" data-i18n="langEn">EN</button>
            </div>
            <div class="theme-switch" id="themeSwitch">
                <button class="theme-btn" data-theme="dark" data-i18n-title="darkMode">ğŸŒ™</button>
                <button class="theme-btn" data-theme="light" data-i18n-title="lightMode">â˜€ï¸</button>
            </div>
        </div>
        <button class="sidebar-toggle" id="sidebarToggle" title="éšè—ä¾§è¾¹æ " data-i18n-title="hideSidebar">
            <span class="toggle-icon">â—€</span>
        </button>
        <div class="canvas-container" id="canvasContainer">
            <div id="canvas-wrapper">
                <svg class="svg-connections" id="connections"></svg>
                <div id="canvas"></div>
            </div>
            <div class="selection-box" id="selectionBox"></div>
        </div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOut" title="ç¼©å°" data-i18n-title="zoomOut">â–</button>
        <input type="number" class="zoom-level" id="zoomLevel" value="100" min="10" max="500" title="è¾“å…¥ç¼©æ”¾ç™¾åˆ†æ¯”" data-i18n-title="zoomLevel">
        <span style="color: #888; font-size: 11px;"></span>
        <button class="zoom-btn" id="zoomIn" title="æ”¾å¤§" data-i18n-title="zoomIn">â•</button>
        <button class="zoom-btn" id="zoomReset" title="é‡ç½®åˆ°100%" data-i18n-title="zoomReset">ğŸ”</button>
        <button class="zoom-btn" id="zoomFit" title="é€‚åº”çª—å£" data-i18n-title="zoomFit">â˜‘ï¸</button>
    </div>

    <script>
        const SUBGRAPH_COLORS = [
            '#8b0000', '#1b237e', '#1b5e20', '#4a148c', '#bf360c',
            '#004d40', '#880e4f', '#004d40', '#33691e', '#bf360c',
            '#311b92', '#e65100', '#01579b', '#1b5e20', '#e65100',
            '#3e2723', '#263238', '#827717', '#f57f17', '#004d40'
        ];

        const i18n = {
            zh: {
                title: 'XMetadataWorkflow',
                langZh: 'ä¸­æ–‡',
                langEn: 'English',
                DroporSelect: 'æ‹–æ”¾æ–‡ä»¶åˆ°æ­¤å¤„ æˆ– ç‚¹å‡»é€‰æ‹©æ–‡ä»¶',
                filetip: 'æ”¯æŒ .png å’Œ .latent\nä»¥åŠ .json (ä¸‰ç§æ ¼å¼)',
                filename: 'æ–‡ä»¶å',
                filetype: 'ç±»å‹',
                filesize: 'å¤§å°',
                resolution: 'åˆ†è¾¨ç‡',
                modified: 'ä¿®æ”¹æ—¥æœŸ',
                nodes: 'èŠ‚ç‚¹è®¡æ•°',
                zoomOut: 'ç¼©å°',
                zoomIn: 'æ”¾å¤§',
                zoomReset: 'é‡ç½®åˆ°100%',
                zoomFit: 'é€‚åº”çª—å£',
                zoomLevel: 'è¾“å…¥ç¼©æ”¾ç™¾åˆ†æ¯”',
                toggleCollapse: 'æœ€å°åŒ–',
                expand: 'å±•å¼€',
                detail: 'è¯¦æƒ…',
                bypass: 'å·² Bypass',
                latent: 'Latent',
                inputParams: 'è¾“å…¥å‚æ•°',
                subgraph: 'å­å›¾',
                status: 'çŠ¶æ€',
                input: 'è¾“å…¥',
                output: 'è¾“å‡º',
                darkMode: 'æš—é»‘æ¨¡å¼',
                lightMode: 'äº®è‰²æ¨¡å¼',
                hideSidebar: 'éšè—ä¾§è¾¹æ ',
                showSidebar: 'æ˜¾ç¤ºä¾§è¾¹æ ',
                noPromptError: 'ä¸æ”¯æŒçš„ JSON æ ¼å¼\n\næ­¤ JSON æ–‡ä»¶æ— æ³•è¯†åˆ«ä¸ºæœ‰æ•ˆçš„å·¥ä½œæµæ ¼å¼ã€‚\n\næ”¯æŒçš„æ ¼å¼ï¼š\nâ€¢ XWorkflowSave ç”Ÿæˆçš„ JSON (å« prompt å­—æ®µ)\nâ€¢ ComfyUI ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ JSON\nâ€¢ ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ JSON\nâ€¢ åŒ…å« prompt å…ƒæ•°æ®çš„ PNG å›¾ç‰‡\nâ€¢ Latent æ½œç©ºé—´æ–‡ä»¶',
                latentFile: 'Latent æ½œç©ºé—´',
                jsonWorkflow: 'JSON å·¥ä½œæµ',
                noPreview: 'æ— æ³•ç›´æ¥é¢„è§ˆ',
                clickToChange: 'ç‚¹å‡»æ›´æ¢æ–‡ä»¶',
                typePng: 'PNG å›¾ç‰‡',
                typeLatent: 'Latent æ½œç©ºé—´',
                typeJson: 'JSON å·¥ä½œæµ',
                unknown: 'æœªçŸ¥',
                copied: 'å·²å¤åˆ¶åˆ°å‰ªè´´æ¿',
                downloadStarted: 'å·²å¼€å§‹ä¸‹è½½',
                lines: 'è¡Œ',
                copy: 'å¤åˆ¶',
                download: 'ä¸‹è½½',
                fileTooLarge: 'æ–‡ä»¶è¿‡å¤§ï¼Œæœ€å¤§æ”¯æŒ 100MB',
                copyTitle: 'å¤åˆ¶èŠ‚ç‚¹åç§°'
            },
            en: {
                title: 'XMetadataWorkflow',
                langZh: 'ä¸­æ–‡',
                langEn: 'English',
                DroporSelect: 'Drop file here\nor click to select',
                filetip: 'Supports .png, .latent\nand .json (three formats)',
                filename: 'Filename',
                filetype: 'Type',
                filesize: 'Size',
                resolution: 'Resolution',
                modified: 'Modified',
                nodes: 'Node count',
                zoomOut: 'Zoom Out',
                zoomIn: 'Zoom In',
                zoomReset: 'Reset 100%',
                zoomFit: 'Fit Window',
                zoomLevel: 'Enter zoom percentage',
                toggleCollapse: 'Collapse',
                expand: 'Expand',
                detail: 'Detail',
                bypass: 'Bypassed',
                latent: 'Latent',
                inputParams: 'Input Params',
                subgraph: 'Subgraph',
                status: 'Status',
                input: 'Input',
                output: 'Output',
                darkMode: 'Dark Mode',
                lightMode: 'Light Mode',
                hideSidebar: 'Hide Sidebar',
                showSidebar: 'Show Sidebar',
                noPromptError: 'Unsupported JSON Format\n\nThis JSON file cannot be recognized as a valid workflow format.\n\nSupported formats:\nâ€¢ JSON from XWorkflowSave (with prompt field)\nâ€¢ ComfyUI web-exported API format JSON\nâ€¢ ComfyUI web-saved full Workflow format JSON\nâ€¢ PNG images with prompt metadata\nâ€¢ Latent files',
                latentFile: 'Latent File',
                jsonWorkflow: 'JSON Workflow',
                noPreview: 'No preview available',
                clickToChange: 'Click to change file',
                typePng: 'PNG Image',
                typeLatent: 'Latent File',
                typeJson: 'JSON Workflow',
                unknown: 'Unknown',
                copied: 'Copied to clipboard',
                downloadStarted: 'Download started',
                lines: 'lines',
                copy: 'Copy',
                download: 'Download',
                fileTooLarge: 'File too large, maximum 100MB supported',
                copyTitle: 'Copy Node Name'
            }
        };

        let currentLang = localStorage.getItem('lang') || 'en';

        /**
         * å›½é™…åŒ–ç¿»è¯‘å‡½æ•°
         * @param {string} key - ç¿»è¯‘é”®å
         * @returns {string} ç¿»è¯‘åçš„æ–‡æœ¬ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›é”®å
         */
        function t(key) {
            return i18n[currentLang][key] || key;
        }

        /**
         * æ ¹æ®å­å›¾IDç”Ÿæˆé¢œè‰²
         * ä½¿ç”¨å“ˆå¸Œç®—æ³•ç¡®ä¿åŒä¸€å­å›¾å§‹ç»ˆè·å¾—ç›¸åŒé¢œè‰²
         * @param {string} subgraphId - å­å›¾ID
         * @returns {string} HSLé¢œè‰²å­—ç¬¦ä¸²
         */
        function getSubgraphColor(subgraphId) {
            if (!subgraphId) return null;
            let hash = 0;
            const idStr = String(subgraphId);
            for (let i = 0; i < idStr.length; i++) {
                hash = idStr.charCodeAt(i) + ((hash << 5) - hash);
            }
            const index = Math.abs(hash) % SUBGRAPH_COLORS.length;
            return SUBGRAPH_COLORS[index];
        }

        let workflowData = null;
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let nodeStates = {};
        let selectedNodeId = null;
        let selectedNodeIds = new Set(); // å¤šé€‰èŠ‚ç‚¹é›†åˆ
        let currentFileType = null; // å­˜å‚¨å½“å‰æ–‡ä»¶ç±»å‹ï¼Œç”¨äºè¯­è¨€åˆ‡æ¢æ—¶æ›´æ–°é¢„è§ˆ
        let currentPreviewUrl = null; // å½“å‰é¢„è§ˆå›¾ç‰‡çš„ Object URLï¼Œç”¨äºå†…å­˜é‡Šæ”¾

        const canvasContainer = document.getElementById('canvasContainer');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const connectionsSvg = document.getElementById('connections');
        const zoomLevel = document.getElementById('zoomLevel');
        const selectionBox = document.getElementById('selectionBox');

        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLang = btn.dataset.lang;
                localStorage.setItem('lang', currentLang);
                updateLanguage();
            });
        });

        document.querySelector(`.lang-btn[data-lang="${currentLang}"]`).classList.add('active');
        updateLanguage();

        let currentTheme = localStorage.getItem('theme') || 'dark';

        /**
         * è®¾ç½®é¡µé¢ä¸»é¢˜ï¼ˆäº®è‰²/æš—è‰²ï¼‰
         * @param {string} theme - ä¸»é¢˜åç§° 'dark' æˆ– 'light'
         */
        function setTheme(theme) {
            currentTheme = theme;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.theme-btn[data-theme="${theme}"]`).classList.add('active');
        }

        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setTheme(btn.dataset.theme);
            });
        });

        setTheme(currentTheme);

        // ä¾§è¾¹æ æŠ˜å åŠŸèƒ½
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        let sidebarCollapsed = false; // é»˜è®¤å±•å¼€ï¼Œä¸æŒä¹…åŒ–å­˜å‚¨

        /**
         * åˆ‡æ¢ä¾§è¾¹æ æ˜¾ç¤º/éšè—çŠ¶æ€
         */
        function toggleSidebar() {
            sidebarCollapsed = !sidebarCollapsed;
            if (sidebarCollapsed) {
                sidebar.classList.add('collapsed');
                sidebarToggle.title = t('showSidebar');
                sidebarToggle.setAttribute('data-i18n-title', 'showSidebar');
            } else {
                sidebar.classList.remove('collapsed');
                sidebarToggle.title = t('hideSidebar');
                sidebarToggle.setAttribute('data-i18n-title', 'hideSidebar');
            }
        }

        sidebarToggle.addEventListener('click', toggleSidebar);

        // åˆå§‹åŒ–ä¾§è¾¹æ çŠ¶æ€ï¼ˆé»˜è®¤å±•å¼€ï¼‰
        sidebarToggle.title = t('hideSidebar');
        sidebarToggle.setAttribute('data-i18n-title', 'hideSidebar');

        function updateLanguage() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = t(key);
            });
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                el.title = t(key);
            });

            // æ›´æ–°æ–‡ä»¶ä¿¡æ¯åŒºåŸŸçš„ç±»å‹æ˜¾ç¤º
            if (currentFileType) {
                const typeMap = {
                    'png': t('typePng'),
                    'latent': t('typeLatent'),
                    'json': t('typeJson')
                };
                document.getElementById('infoType').textContent = typeMap[currentFileType] || currentFileType;

                // æ›´æ–°é¢„è§ˆåŒºåŸŸçš„æ–‡æœ¬
                if (currentFileType === 'latent') {
                    displayLatentPreview();
                } else if (currentFileType === 'json') {
                    displayNoPreview();
                } else if (currentFileType === 'png') {
                    // æ›´æ–° PNG é¢„è§ˆçš„ title
                    const placeholder = document.getElementById('filePlaceholder');
                    if (placeholder) {
                        placeholder.title = t('clickToChange');
                    }
                }
            }

            renderWorkflow();
        }

        const fileArea = document.getElementById('fileArea');
        const filePlaceholder = document.getElementById('filePlaceholder');
        const fileInput = document.getElementById('fileInput');

        filePlaceholder.addEventListener('click', () => fileInput.click());
        fileArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            filePlaceholder.classList.add('dragover');
        });
        fileArea.addEventListener('dragleave', () => {
            filePlaceholder.classList.remove('dragover');
        });
        fileArea.addEventListener('drop', (e) => {
            e.preventDefault();
            filePlaceholder.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        });
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        document.getElementById('zoomIn').addEventListener('click', () => {
            setZoom(scale * 1.2, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });
        document.getElementById('zoomOut').addEventListener('click', () => {
            setZoom(scale / 1.2, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });
        document.getElementById('zoomReset').addEventListener('click', () => {
            setZoom(1, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });
        document.getElementById('zoomFit').addEventListener('click', () => {
            fitToView();
        });

        zoomLevel.addEventListener('change', () => {
            const newScale = Math.max(0.1, Math.min(5, parseInt(zoomLevel.value) / 100));
            setZoom(newScale, canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);
        });

        /**
         * è‡ªé€‚åº”è§†å›¾ - ç¼©æ”¾å’Œå¹³ç§»ä»¥æ˜¾ç¤ºæ‰€æœ‰èŠ‚ç‚¹
         * è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†ï¼Œç„¶åè°ƒæ•´ç¼©æ”¾å’Œå¹³ç§»ä½¿æ‰€æœ‰èŠ‚ç‚¹å¯è§
         */
        function fitToView() {
            if (!workflowData || !workflowData.nodes) return;

            const nodes = document.querySelectorAll('.node');
            if (nodes.length === 0) return;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†
            nodes.forEach(node => {
                const x = parseFloat(node.style.left);
                const y = parseFloat(node.style.top);
                const w = node.offsetWidth;
                const h = node.offsetHeight;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + w);
                maxY = Math.max(maxY, y + h);
            });

            const contentWidth = maxX - minX + 100;
            const contentHeight = maxY - minY + 100;

            // è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹
            const scaleX = canvasContainer.clientWidth / contentWidth;
            const scaleY = canvasContainer.clientHeight / contentHeight;
            const newScale = Math.min(scaleX, scaleY, 2);

            // è®¡ç®—å¹³ç§»é‡ä½¿å†…å®¹å±…ä¸­
            const contentCenterX = (minX + maxX) / 2 * newScale;
            const contentCenterY = (minY + maxY) / 2 * newScale;
            const containerCenterX = canvasContainer.clientWidth / 2;
            const containerCenterY = canvasContainer.clientHeight / 2;

            panX = containerCenterX - contentCenterX;
            panY = containerCenterY - contentCenterY;

            scale = newScale;
            updateTransform();
        }

        document.addEventListener('wheel', (e) => {
            if (!workflowData || !workflowData.nodes) return;
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            setZoom(scale * delta, e.clientX, e.clientY);
        }, { passive: false });

        let isPanning = false;
        let panStartX, panStartY;

        // æ¡†é€‰ç›¸å…³å˜é‡
        let isSelecting = false;
        let selectionStartX, selectionStartY;
        let isMultiDragging = false;
        let multiDragStartX, multiDragStartY;
        let multiDragNodePositions = new Map();

        // æ‹–åŠ¨æ ‡è®°ï¼Œç”¨äºé˜²æ­¢æ‹–åŠ¨åè§¦å‘ç‚¹å‡»äº‹ä»¶
        let justFinishedDrag = false;

        // èŠ‚ç‚¹æ‹‰ä¼¸çŠ¶æ€å˜é‡
        let isResizing = false;
        let resizeNodeId = null;
        let resizeDirection = null;
        let resizeStartX = 0;
        let resizeStartY = 0;
        let resizeStartWidth = 0;
        let resizeStartHeight = 0;
        let resizeStartLeft = 0;
        let resizeStartTop = 0;
        const MIN_NODE_WIDTH = 180;
        const MIN_NODE_HEIGHT = 60;

        canvasContainer.addEventListener('mousedown', (e) => {
            // Ctrl+å·¦é”®ï¼šå¼€å§‹æ¡†é€‰
            if (e.ctrlKey && e.button === 0 && (e.target === canvasContainer || e.target === canvasWrapper)) {
                isSelecting = true;
                // ä½¿ç”¨ç›¸å¯¹äº canvasContainer çš„åæ ‡ï¼ˆä¸å— transform å½±å“ï¼‰
                const rect = canvasContainer.getBoundingClientRect();
                selectionStartX = e.clientX - rect.left;
                selectionStartY = e.clientY - rect.top;
                selectionBox.style.display = 'block';
                selectionBox.style.left = selectionStartX + 'px';
                selectionBox.style.top = selectionStartY + 'px';
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                e.preventDefault();
                return;
            }

            // æ™®é€šæƒ…å†µï¼šå¹³ç§»ç”»å¸ƒ
            if (e.target === canvasContainer || e.target === canvasWrapper) {
                isPanning = true;
                panStartX = e.clientX - panX;
                panStartY = e.clientY - panY;
                canvasContainer.style.cursor = 'grabbing';
            }
        });

        canvasContainer.addEventListener('dblclick', (e) => {
            if (e.target === canvasContainer || e.target === canvasWrapper) {
                deselectAll();
                selectedNodeIds.clear();
                updateMultiSelection();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (document.activeElement.tagName === 'INPUT') {
                    document.activeElement.blur();
                } else {
                    deselectAll();
                    selectedNodeIds.clear();
                    updateMultiSelection();
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            // å¤„ç†èŠ‚ç‚¹æ‹‰ä¼¸ - æ”¾åœ¨æœ€å‰é¢ç¡®ä¿åŠæ—¶å“åº”
            if (isResizing && resizeNodeId) {
                const nodeEl = document.querySelector(`[data-node-id="${resizeNodeId}"]`);
                if (nodeEl) {
                    // è®¡ç®—é¼ æ ‡ç§»åŠ¨è·ç¦»ï¼ˆè€ƒè™‘ç”»å¸ƒç¼©æ”¾ï¼‰
                    const dx = (e.clientX - resizeStartX) / scale;
                    const dy = (e.clientY - resizeStartY) / scale;

                    let newWidth = resizeStartWidth;
                    let newHeight = resizeStartHeight;
                    let newLeft = resizeStartLeft;
                    let newTop = resizeStartTop;

                    // æ ¹æ®æ‹‰ä¼¸æ–¹å‘è®¡ç®—æ–°çš„å°ºå¯¸å’Œä½ç½®
                    switch (resizeDirection) {
                        case 'e': // ä¸œ - å³è¾¹
                            newWidth = Math.max(MIN_NODE_WIDTH, resizeStartWidth + dx);
                            break;
                        case 'w': // è¥¿ - å·¦è¾¹
                            newWidth = Math.max(MIN_NODE_WIDTH, resizeStartWidth - dx);
                            newLeft = resizeStartLeft + (resizeStartWidth - newWidth);
                            break;
                        case 's': // å— - ä¸‹è¾¹
                            newHeight = Math.max(MIN_NODE_HEIGHT, resizeStartHeight + dy);
                            break;
                        case 'n': // åŒ— - ä¸Šè¾¹
                            newHeight = Math.max(MIN_NODE_HEIGHT, resizeStartHeight - dy);
                            newTop = resizeStartTop + (resizeStartHeight - newHeight);
                            break;
                        case 'se': // ä¸œå— - å³ä¸‹è§’
                            newWidth = Math.max(MIN_NODE_WIDTH, resizeStartWidth + dx);
                            newHeight = Math.max(MIN_NODE_HEIGHT, resizeStartHeight + dy);
                            break;
                        case 'sw': // è¥¿å— - å·¦ä¸‹è§’
                            newWidth = Math.max(MIN_NODE_WIDTH, resizeStartWidth - dx);
                            newHeight = Math.max(MIN_NODE_HEIGHT, resizeStartHeight + dy);
                            newLeft = resizeStartLeft + (resizeStartWidth - newWidth);
                            break;
                        case 'ne': // ä¸œåŒ— - å³ä¸Šè§’
                            newWidth = Math.max(MIN_NODE_WIDTH, resizeStartWidth + dx);
                            newHeight = Math.max(MIN_NODE_HEIGHT, resizeStartHeight - dy);
                            newTop = resizeStartTop + (resizeStartHeight - newHeight);
                            break;
                        case 'nw': // è¥¿åŒ— - å·¦ä¸Šè§’
                            newWidth = Math.max(MIN_NODE_WIDTH, resizeStartWidth - dx);
                            newHeight = Math.max(MIN_NODE_HEIGHT, resizeStartHeight - dy);
                            newLeft = resizeStartLeft + (resizeStartWidth - newWidth);
                            newTop = resizeStartTop + (resizeStartHeight - newHeight);
                            break;
                    }

                    // åº”ç”¨æ–°çš„å°ºå¯¸å’Œä½ç½®
                    nodeEl.style.width = newWidth + 'px';
                    nodeEl.style.height = newHeight + 'px';
                    nodeEl.style.left = newLeft + 'px';
                    nodeEl.style.top = newTop + 'px';

                    // ç«‹å³æ›´æ–°è¿æ¥çº¿
                    updateConnectionPaths();
                    updateConnectionHighlight();
                }
                return; // æ‹‰ä¼¸æ—¶é˜»æ­¢å…¶ä»–æ“ä½œ
            }

            if (isPanning) {
                panX = e.clientX - panStartX;
                panY = e.clientY - panStartY;
                updateTransform();
            }

            // æ›´æ–°æ¡†é€‰æ¡†
            if (isSelecting) {
                // ä½¿ç”¨ç›¸å¯¹äº canvasContainer çš„åæ ‡ï¼ˆä¸å— transform å½±å“ï¼‰
                const rect = canvasContainer.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                const left = Math.min(selectionStartX, currentX);
                const top = Math.min(selectionStartY, currentY);
                const width = Math.abs(currentX - selectionStartX);
                const height = Math.abs(currentY - selectionStartY);

                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
            }

            // å¤šèŠ‚ç‚¹æ‹–åŠ¨
            if (isMultiDragging && selectedNodeIds.size > 0) {
                const dx = (e.clientX - multiDragStartX) / scale;
                const dy = (e.clientY - multiDragStartY) / scale;

                selectedNodeIds.forEach(nodeId => {
                    const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
                    const startPos = multiDragNodePositions.get(nodeId);
                    if (nodeEl && startPos) {
                        nodeEl.style.left = (startPos.x + dx) + 'px';
                        nodeEl.style.top = (startPos.y + dy) + 'px';
                    }
                });

                updateConnectionPaths();
                updateConnectionHighlight();
            }
        });

        document.addEventListener('mouseup', (e) => {
            // ç»“æŸèŠ‚ç‚¹æ‹‰ä¼¸ - æ”¾åœ¨æœ€å‰é¢ç¡®ä¿åŠæ—¶æ¸…ç†çŠ¶æ€
            if (isResizing) {
                const nodeEl = document.querySelector(`[data-node-id="${resizeNodeId}"]`);
                if (nodeEl) {
                    // ç§»é™¤æ‹‰ä¼¸ä¸­æ ·å¼
                    nodeEl.classList.remove('resizing');
                    nodeEl.querySelectorAll('.resize-handle').forEach(h => {
                        h.classList.remove('active');
                    });

                    // ä¿å­˜èŠ‚ç‚¹å°ºå¯¸çŠ¶æ€
                    if (!nodeStates[resizeNodeId]) {
                        nodeStates[resizeNodeId] = {};
                    }
                    nodeStates[resizeNodeId].width = nodeEl.offsetWidth;
                    nodeStates[resizeNodeId].height = nodeEl.offsetHeight;

                    // ä¿å­˜èŠ‚ç‚¹ä½ç½®ï¼ˆå¦‚æœä½ç½®å‘ç”Ÿäº†å˜åŒ–ï¼‰
                    const newLeft = parseFloat(nodeEl.style.left);
                    const newTop = parseFloat(nodeEl.style.top);
                    if (newLeft !== resizeStartLeft || newTop !== resizeStartTop) {
                        if (!workflowData.nodePositions) {
                            workflowData.nodePositions = {};
                        }
                        workflowData.nodePositions[resizeNodeId] = {
                            x: newLeft,
                            y: newTop
                        };
                    }
                }

                // ç«‹å³æ¸…ç†æ‰€æœ‰æ‹‰ä¼¸çŠ¶æ€
                document.body.style.userSelect = '';
                document.body.style.webkitUserSelect = '';
                isResizing = false;
                resizeNodeId = null;
                resizeDirection = null;

                // è®¾ç½®æ ‡è®°ï¼Œé˜²æ­¢è§¦å‘ç‚¹å‡»äº‹ä»¶
                justFinishedDrag = true;
                setTimeout(() => {
                    justFinishedDrag = false;
                }, 50);
            }

            // ç»“æŸæ¡†é€‰
            if (isSelecting) {
                const containerRect = canvasContainer.getBoundingClientRect();
                const endX = e.clientX - containerRect.left;
                const endY = e.clientY - containerRect.top;

                // é€‰æ‹©æ¡†çš„è§†å£åæ ‡
                const selLeft = Math.min(selectionStartX, endX);
                const selTop = Math.min(selectionStartY, endY);
                const selRight = Math.max(selectionStartX, endX);
                const selBottom = Math.max(selectionStartY, endY);

                // å°†é€‰æ‹©æ¡†åæ ‡è½¬æ¢ä¸ºèŠ‚ç‚¹åæ ‡ç³»ï¼ˆè€ƒè™‘ pan å’Œ scaleï¼‰
                const nodeLeft = (selLeft - panX) / scale;
                const nodeTop = (selTop - panY) / scale;
                const nodeRight = (selRight - panX) / scale;
                const nodeBottom = (selBottom - panY) / scale;

                // æ£€æµ‹å“ªäº›èŠ‚ç‚¹åœ¨é€‰æ‹©æ¡†å†…
                document.querySelectorAll('.node').forEach(nodeEl => {
                    const nodeX = parseFloat(nodeEl.style.left);
                    const nodeY = parseFloat(nodeEl.style.top);
                    const nodeW = nodeEl.offsetWidth;
                    const nodeH = nodeEl.offsetHeight;

                    // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åœ¨é€‰æ‹©æ¡†å†…ï¼ˆéƒ¨åˆ†é‡å ä¹Ÿç®—ï¼‰
                    if (nodeX < nodeRight && nodeX + nodeW > nodeLeft &&
                        nodeY < nodeBottom && nodeY + nodeH > nodeTop) {
                        const nodeId = nodeEl.dataset.nodeId;
                        selectedNodeIds.add(nodeId);
                    }
                });

                updateMultiSelection();
                selectionBox.style.display = 'none';
                isSelecting = false;
            }

            // ç»“æŸå¤šèŠ‚ç‚¹æ‹–åŠ¨
            if (isMultiDragging) {
                // ä¿å­˜æ–°ä½ç½®
                selectedNodeIds.forEach(nodeId => {
                    const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
                    if (nodeEl) {
                        if (!workflowData.nodePositions) {
                            workflowData.nodePositions = {};
                        }
                        workflowData.nodePositions[nodeId] = {
                            x: parseFloat(nodeEl.style.left),
                            y: parseFloat(nodeEl.style.top)
                        };
                    }
                });

                document.body.style.userSelect = '';
                document.body.style.webkitUserSelect = '';
                isMultiDragging = false;
                multiDragNodePositions.clear();

                // è®¾ç½®æ ‡è®°ï¼Œé˜²æ­¢è§¦å‘ç‚¹å‡»äº‹ä»¶
                justFinishedDrag = true;
                // å»¶è¿Ÿé‡ç½®æ ‡è®°ï¼Œç¡®ä¿ click äº‹ä»¶èƒ½æ£€æµ‹åˆ°
                setTimeout(() => {
                    justFinishedDrag = false;
                }, 50);
            }

            isPanning = false;
            canvasContainer.style.cursor = 'default';
        });

        /**
         * æ›´æ–°å¤šé€‰èŠ‚ç‚¹çš„è§†è§‰çŠ¶æ€
         */
        function updateMultiSelection() {
            document.querySelectorAll('.node').forEach(nodeEl => {
                const nodeId = nodeEl.dataset.nodeId;
                if (selectedNodeIds.has(nodeId)) {
                    nodeEl.classList.add('multi-selected');
                } else {
                    nodeEl.classList.remove('multi-selected');
                }
            });
        }

        /**
         * è®¾ç½®ç”»å¸ƒç¼©æ”¾çº§åˆ«
         * @param {number} newScale - æ–°çš„ç¼©æ”¾æ¯”ä¾‹
         * @param {number} centerX - ç¼©æ”¾ä¸­å¿ƒç‚¹ X åæ ‡
         * @param {number} centerY - ç¼©æ”¾ä¸­å¿ƒç‚¹ Y åæ ‡
         */
        function setZoom(newScale, centerX, centerY) {
            newScale = Math.max(0.1, Math.min(5, newScale));

            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = centerX - rect.left;
            const mouseY = centerY - rect.top;

            // ä»¥é¼ æ ‡ä½ç½®ä¸ºä¸­å¿ƒè¿›è¡Œç¼©æ”¾
            const scaleChange = newScale / scale;
            panX = mouseX - (mouseX - panX) * scaleChange;
            panY = mouseY - (mouseY - panY) * scaleChange;

            scale = newScale;
            updateTransform();
        }

        /**
         * æ›´æ–°ç”»å¸ƒçš„å˜æ¢ï¼ˆå¹³ç§»å’Œç¼©æ”¾ï¼‰
         * åŒæ—¶æ›´æ–°ç¼©æ”¾çº§åˆ«æ˜¾ç¤ºå’Œè¿æ¥çº¿ä½ç½®
         */
        function updateTransform() {
            canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            zoomLevel.value = Math.round(scale * 100);
            updateConnectionPaths();
        }

        /**
         * å¤„ç†ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶
         * æµç¨‹ï¼šæ£€æŸ¥æ–‡ä»¶å¤§å° -> è¯»å–æ–‡ä»¶ -> æå–å…ƒæ•°æ® -> è§£æå·¥ä½œæµ -> æ¸²æŸ“ -> è‡ªé€‚åº”è§†å›¾
         * @param {File} file - ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶å¯¹è±¡
         */
        async function handleFile(file) {
            // æ–‡ä»¶å¤§å°é™åˆ¶ï¼š100MB
            const MAX_FILE_SIZE = 100 * 1024 * 1024;
            if (file.size > MAX_FILE_SIZE) {
                alert(t('fileTooLarge'));
                return;
            }

            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);

            try {
                const metadata = await readMetadataFromFile(uint8Array, file.name);
                if (!metadata) {
                    return;
                }

                updateFileInfo(file, uint8Array);

                // è§£æå·¥ä½œæµæ•°æ®
                workflowData = parseWorkflow(metadata);

                // é‡ç½®è§†å›¾çŠ¶æ€
                scale = 1;
                panX = 50;
                panY = 50;
                nodeStates = {};

                // æ¸²æŸ“å¹¶è‡ªé€‚åº”è§†å›¾
                renderWorkflow();
                fitToView();

                document.getElementById('infoNodeCount').textContent = Object.keys(workflowData.nodes).length;
            } catch (error) {
                console.error(error);
            }
        }

        /**
         * æ›´æ–°æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤º
         * @param {File} file - æ–‡ä»¶å¯¹è±¡
         * @param {Uint8Array} uint8Array - æ–‡ä»¶å†…å®¹çš„äºŒè¿›åˆ¶æ•°æ®
         */
        function updateFileInfo(file, uint8Array) {
            const filename = file.name;
            const ext = filename.split('.').pop().toLowerCase();
            const size = formatFileSize(file.size);
            const lastModified = new Date(file.lastModified).toLocaleString(currentLang === 'zh' ? 'zh-CN' : 'en-US');

            // ä¿å­˜å½“å‰æ–‡ä»¶ç±»å‹ï¼Œç”¨äºè¯­è¨€åˆ‡æ¢æ—¶æ›´æ–°
            currentFileType = ext;

            document.getElementById('infoFilename').textContent = filename;
            document.getElementById('infoSize').textContent = size;
            document.getElementById('infoModified').textContent = lastModified;

            // ä½¿ç”¨ i18n è·å–æ–‡ä»¶ç±»å‹åç§°
            const typeMap = {
                'png': t('typePng'),
                'latent': t('typeLatent'),
                'json': t('typeJson')
            };
            document.getElementById('infoType').textContent = typeMap[ext] || ext;

            // æ ¹æ®æ–‡ä»¶ç±»å‹æ˜¾ç¤ºä¸åŒçš„é¢„è§ˆå’Œä¿¡æ¯
            if (ext === 'png') {
                const dims = getPngDimensions(uint8Array);
                if (dims) {
                    document.getElementById('infoResolution').textContent = `${dims.width} Ã— ${dims.height}`;
                    displayImagePreview(uint8Array);
                } else {
                    document.getElementById('infoResolution').textContent = t('unknown');
                }
            } else if (ext === 'latent') {
                document.getElementById('infoResolution').innerHTML = `<span class="latent-badge">${t('latent')}</span>`;
                displayLatentPreview();
            } else {
                document.getElementById('infoResolution').textContent = '-';
                displayNoPreview();
            }
        }

        /**
         * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°ä¸ºæ˜“è¯»æ ¼å¼
         * @param {number} bytes - å­—èŠ‚æ•°
         * @returns {string} æ ¼å¼åŒ–åçš„æ–‡ä»¶å¤§å° (å¦‚ "1.5 MB")
         */
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        /**
         * ä» PNG äºŒè¿›åˆ¶æ•°æ®ä¸­æå–å›¾ç‰‡å°ºå¯¸
         * è§£æ IHDR chunk è·å–å®½åº¦å’Œé«˜åº¦
         * @param {Uint8Array} data - PNG æ–‡ä»¶çš„äºŒè¿›åˆ¶æ•°æ®
         * @returns {Object|null} åŒ…å« width å’Œ height çš„å¯¹è±¡ï¼Œè§£æå¤±è´¥è¿”å› null
         */
        function getPngDimensions(data) {
            try {
                if (data.length < 24) return null;

                // éªŒè¯ PNG æ–‡ä»¶ç­¾å
                const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
                for (let i = 0; i < 8; i++) {
                    if (data[i] !== pngSignature[i]) return null;
                }

                // éå† chunks æŸ¥æ‰¾ IHDR
                let offset = 8;
                while (offset < data.length - 12) {
                    const length = (data[offset] << 24) | (data[offset + 1] << 16) |
                                   (data[offset + 2] << 8) | data[offset + 3];

                    const type = String.fromCharCode(
                        data[offset + 4], data[offset + 5],
                        data[offset + 6], data[offset + 7]
                    );

                    if (type === 'IHDR') {
                        const width = (data[offset + 8] << 24) | (data[offset + 9] << 16) |
                                     (data[offset + 10] << 8) | data[offset + 11];
                        const height = (data[offset + 12] << 24) | (data[offset + 13] << 16) |
                                      (data[offset + 14] << 8) | data[offset + 15];
                        return { width, height };
                    }

                    if (type === 'IEND') break;
                    offset += 12 + length;
                }
            } catch (e) {
                console.error('Error getting PNG dimensions:', e);
            }
            return null;
        }

        /**
         * æ˜¾ç¤º PNG å›¾ç‰‡é¢„è§ˆ
         * @param {Uint8Array} uint8Array - PNG æ–‡ä»¶çš„äºŒè¿›åˆ¶æ•°æ®
         */
        function displayImagePreview(uint8Array) {
            // é‡Šæ”¾ä¸Šä¸€æ¬¡çš„ Object URLï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
            if (currentPreviewUrl) {
                URL.revokeObjectURL(currentPreviewUrl);
                currentPreviewUrl = null;
            }

            const blob = new Blob([uint8Array], { type: 'image/png' });
            currentPreviewUrl = URL.createObjectURL(blob);

            const preview = document.getElementById('filePreview');
            const placeholder = document.getElementById('filePlaceholder');

            placeholder.innerHTML = '<img src="' + currentPreviewUrl + '" alt="Preview" style="max-width: 100%; max-height: 100%; object-fit: contain;">';
            placeholder.style.cursor = 'pointer';
            placeholder.title = t('clickToChange');
        }

        function displayLatentPreview() {
            const placeholder = document.getElementById('filePlaceholder');
            placeholder.innerHTML = `
                <span class="icon">ğŸ§ </span>
                <span>${t('latentFile')}</span>
                <span style="font-size: 10px; color: #555; margin-top: 8px;">${t('noPreview')}</span>
                <span style="font-size: 10px; color: #444; margin-top: 4px;">${t('clickToChange')}</span>
            `;
        }

        function displayNoPreview() {
            const placeholder = document.getElementById('filePlaceholder');
            placeholder.innerHTML = `
                <span class="icon">ğŸ“„</span>
                <span>${t('jsonWorkflow')}</span>
                <span style="font-size: 10px; color: #444; margin-top: 4px;">${t('clickToChange')}</span>
            `;
        }

        /**
         * æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©å¯¹åº”çš„å…ƒæ•°æ®è¯»å–å‡½æ•°
         * å¤„ç†æµç¨‹ï¼š
         * 1. .latent æ–‡ä»¶ -> readLatentMetadata (è¯»å– latent æ–‡ä»¶çš„å¤´éƒ¨å…ƒæ•°æ®)
         * 2. .json æ–‡ä»¶ -> readJsonMetadata (è‡ªåŠ¨è¯†åˆ«å¹¶è§£æä¸¤ç§ prompt æ ¼å¼)
         * 3. å…¶ä»–æ–‡ä»¶ (å¦‚ .png) -> readPngMetadata (ä» PNG çš„ tEXt/iTXt chunk è¯»å–)
         *
         * è¿”å›æ ¼å¼: { prompt: {...}, workflow: {...} }
         * - prompt: ComfyUI API æ ¼å¼çš„å·¥ä½œæµæ•°æ®
         * - workflow: å®Œæ•´çš„ Workflow æ ¼å¼ï¼ˆåŒ…å«èŠ‚ç‚¹ä½ç½®ç­‰ä¿¡æ¯ï¼Œå¯èƒ½ä¸º nullï¼‰
         */
        async function readMetadataFromFile(data, filename) {
            if (filename.toLowerCase().endsWith('.latent')) {
                return readLatentMetadata(data);
            } else if (filename.toLowerCase().endsWith('.json')) {
                return readJsonMetadata(data);
            } else {
                return readPngMetadata(data);
            }
        }

        /**
         * å°†å®Œæ•´ Workflow æ ¼å¼è½¬æ¢ä¸º Prompt API æ ¼å¼
         * å®Œæ•´ Workflow æ ¼å¼åŒ…å«æ›´å¤šå…ƒæ•°æ®ï¼ˆèŠ‚ç‚¹ä½ç½®ã€å¤§å°ç­‰ï¼‰ï¼Œä½†éœ€è¦è½¬æ¢æ‰èƒ½ä½¿ç”¨
         *
         * @param {Object} workflow - å®Œæ•´ Workflow æ ¼å¼çš„ JSON å¯¹è±¡
         * @returns {Object} - Prompt API æ ¼å¼çš„å¯¹è±¡
         */
        function convertWorkflowToPrompt(workflow) {
            const prompt = {};
            const nodeMap = new Map();

            // é¦–å…ˆå»ºç«‹èŠ‚ç‚¹ ID æ˜ å°„
            for (const node of workflow.nodes || []) {
                nodeMap.set(node.id, node);
            }

            // æ„å»ºé“¾æ¥æ˜ å°„ï¼šlinkId -> { origin_id, origin_slot, target_id, target_slot }
            const linkMap = new Map();
            for (const link of workflow.links || []) {
                // link æ ¼å¼: [id, origin_id, origin_slot, target_id, target_slot, type]
                if (link.length >= 5) {
                    linkMap.set(link[0], {
                        origin_id: link[1],
                        origin_slot: link[2],
                        target_id: link[3],
                        target_slot: link[4]
                    });
                }
            }

            // è½¬æ¢æ¯ä¸ªèŠ‚ç‚¹
            for (const node of workflow.nodes || []) {
                const nodeData = {
                    inputs: {},
                    class_type: node.type,
                    _meta: {
                        title: node.properties?.["Node name for S&R"] || node.type
                    }
                };

                // ä¿å­˜èŠ‚ç‚¹ä½ç½®ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                if (node.pos && Array.isArray(node.pos) && node.pos.length >= 2) {
                    nodeData._meta.pos = [node.pos[0], node.pos[1]];
                }
                if (node.size && Array.isArray(node.size) && node.size.length >= 2) {
                    nodeData._meta.size = [node.size[0], node.size[1]];
                }

                // å¤„ç† Note å’Œ MarkdownNote èŠ‚ç‚¹ï¼ˆæ²¡æœ‰ inputsï¼Œä½†æœ‰ widgets_valuesï¼‰
                if (node.type === 'Note' || node.type === 'MarkdownNote') {
                    if (node.widgets_values && node.widgets_values.length > 0) {
                        nodeData.inputs.text = node.widgets_values[0];
                    }
                    prompt[String(node.id)] = nodeData;
                    continue;
                }

                // æ”¶é›†è¯¥èŠ‚ç‚¹ä½œä¸ºç›®æ ‡çš„æ‰€æœ‰é“¾æ¥ï¼ˆç”¨äºç¡®å®šè¾“å…¥è¿æ¥ï¼‰
                const incomingLinks = [];
                for (const [linkId, linkInfo] of linkMap) {
                    if (linkInfo.target_id === node.id) {
                        incomingLinks.push(linkInfo);
                    }
                }

                // å¤„ç† widgets_values å’Œ inputs çš„é…å¯¹
                let widgetIndex = 0;

                for (const input of node.inputs || []) {
                    if (input.link !== undefined && input.link !== null) {
                        // ä¼˜å…ˆå¤„ç†è¿æ¥è¾“å…¥ï¼ˆå³ä½¿ input ä¹Ÿæœ‰ widgetï¼‰
                        const linkInfo = linkMap.get(input.link);
                        if (linkInfo) {
                            nodeData.inputs[input.name] = [
                                String(linkInfo.origin_id),
                                linkInfo.origin_slot
                            ];
                        }
                        // å¦‚æœè¿™ä¸ªè¾“å…¥ä¹Ÿæœ‰ widgetï¼Œéœ€è¦è·³è¿‡å¯¹åº”çš„ widgetIndex
                        if (input.widget && node.widgets_values) {
                            widgetIndex++;
                        }
                    } else if (input.widget && node.widgets_values && widgetIndex < node.widgets_values.length) {
                        // è¿™æ˜¯ widget å‚æ•°ï¼ˆæ²¡æœ‰è¿æ¥ï¼‰ï¼Œä» widgets_values å–å€¼
                        nodeData.inputs[input.name] = node.widgets_values[widgetIndex];
                        widgetIndex++;
                    }
                }

                prompt[String(node.id)] = nodeData;
            }

            return prompt;
        }

        /**
         * åˆå¹¶ prompt å’Œ full_workflow çš„æ•°æ®
         * ä»¥ full_workflow è½¬æ¢åçš„æ•°æ®ä¸ºåŸºç¡€ï¼Œç”¨ prompt ä¸­çš„æ‰§è¡Œç»“æœè¡¥å……
         *
         * @param {Object} promptData - prompt æ ¼å¼çš„æ•°æ®ï¼ˆåŒ…å«æ‰§è¡Œç»“æœï¼‰
         * @param {Object} workflowData - full_workflow æ ¼å¼çš„æ•°æ®ï¼ˆåŒ…å«å®Œæ•´ç»“æ„ï¼‰
         * @returns {Object} - åˆå¹¶åçš„ prompt æ ¼å¼æ•°æ®
         */
        function mergePromptAndWorkflow(promptData, workflowData) {
            // é¦–å…ˆå°† full_workflow è½¬æ¢ä¸º prompt æ ¼å¼
            const merged = convertWorkflowToPrompt(workflowData);

            // ç„¶åä»åŸå§‹ prompt ä¸­è¡¥å……æ‰§è¡Œç»“æœ
            for (const [nodeId, nodeData] of Object.entries(promptData)) {
                if (!merged[nodeId]) {
                    // å¦‚æœ merged ä¸­æ²¡æœ‰è¿™ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥æ·»åŠ 
                    merged[nodeId] = nodeData;
                    continue;
                }

                if (nodeData.inputs) {
                    // ç¡®ä¿ merged èŠ‚ç‚¹æœ‰ inputs å¯¹è±¡
                    if (!merged[nodeId].inputs) {
                        merged[nodeId].inputs = {};
                    }

                    // éå† prompt ä¸­çš„ inputsï¼Œå°†æ‰§è¡Œç»“æœåˆå¹¶åˆ° merged
                    for (const [inputName, inputValue] of Object.entries(nodeData.inputs)) {
                        // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯æ•°ç»„ï¼ˆè¡¨ç¤ºè¿æ¥ï¼‰ï¼Œä¿ç•™ merged ä¸­çš„å€¼
                        // å¦åˆ™ä½¿ç”¨ prompt ä¸­çš„å€¼ï¼ˆæ‰§è¡Œç»“æœï¼‰
                        if (!Array.isArray(inputValue)) {
                            merged[nodeId].inputs[inputName] = inputValue;
                        }
                    }
                }
            }

            return merged;
        }

        /**
         * è¯»å– JSON æ–‡ä»¶çš„å…ƒæ•°æ®
         * å¤„ç†é€»è¾‘ï¼š
         * - æ”¯æŒåŒ…å« prompt å­—æ®µçš„ JSON (å¦‚ XWorkflowSave ç”Ÿæˆçš„)
         * - æ”¯æŒ ComfyUI å®˜æ–¹ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ JSON (ç›´æ¥æ˜¯ prompt æ•°æ®)
         * - æ”¯æŒ ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ JSON (åŒ…å« nodes æ•°ç»„)
         * - è¿”å›æ ¼å¼: { prompt: {...}, workflow: {...} }
         */
        async function readJsonMetadata(data) {
            try {
                const textDecoder = new TextDecoder('utf-8');
                const text = textDecoder.decode(data);
                const json = JSON.parse(text);

                // æƒ…å†µ1: åŒ…å« prompt å­—æ®µçš„ JSON (XWorkflowSave)
                // å¯èƒ½åŒæ—¶åŒ…å« workflow å­—æ®µæˆ– full_workflow å­—æ®µ (merge æ¨¡å¼)
                if (json.prompt) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰ full_workflow (merge æ¨¡å¼)
                    // full_workflow åŒ…å«æ›´å®Œæ•´çš„æ•°æ®ï¼Œéœ€è¦ä¸ prompt åˆå¹¶
                    if (json.full_workflow && json.full_workflow.nodes) {
                        // åˆå¹¶ prompt å’Œ full_workflow çš„æ•°æ®
                        const mergedPrompt = mergePromptAndWorkflow(
                            json.prompt,
                            json.full_workflow
                        );
                        return {
                            prompt: mergedPrompt,
                            workflow: json.full_workflow
                        };
                    }
                    // å¦åˆ™ä½¿ç”¨æ ‡å‡†çš„ workflow å­—æ®µ
                    return {
                        prompt: json.prompt,
                        workflow: json.workflow || null
                    };
                }

                // æƒ…å†µ2: ComfyUI å®˜æ–¹ç½‘é¡µå¯¼å‡ºçš„ API æ ¼å¼ JSON
                // ç‰¹å¾: ç›´æ¥æ˜¯èŠ‚ç‚¹æ˜ å°„è¡¨ï¼Œé”®æ˜¯æ•°å­—å­—ç¬¦ä¸²ï¼Œå€¼åŒ…å« inputs å’Œ class_type
                const keys = Object.keys(json);
                const isPromptFormat = keys.length > 0 && keys.every(key => {
                    const node = json[key];
                    return node && typeof node === 'object' &&
                           (node.inputs !== undefined || node.class_type !== undefined);
                });

                if (isPromptFormat) {
                    return { prompt: json, workflow: null };
                }

                // æƒ…å†µ3: ComfyUI ç½‘é¡µä¿å­˜çš„å®Œæ•´ Workflow æ ¼å¼ JSON
                // ç‰¹å¾: åŒ…å« nodes æ•°ç»„å’Œ links æ•°ç»„
                if (json.nodes && Array.isArray(json.nodes) && json.links && Array.isArray(json.links)) {
                    const prompt = convertWorkflowToPrompt(json);
                    return { prompt: prompt, workflow: json };
                }

                // æ— æ³•è¯†åˆ«çš„æ ¼å¼
                alert(t('noPromptError'));
                return null;
            } catch (e) {
                console.error('JSON metadata read error:', e);
                return null;
            }
        }

        /**
         * ä» PNG æ–‡ä»¶ä¸­è¯»å–å…ƒæ•°æ®
         * PNG æ ¼å¼: å…ƒæ•°æ®å­˜å‚¨åœ¨ tEXt æˆ– iTXt chunk ä¸­
         * è¿”å›æ ¼å¼: { prompt: "...", workflow: "..." } (å­—ç¬¦ä¸²æ ¼å¼ï¼Œéœ€è¦ parseWorkflow è¿›ä¸€æ­¥è§£æ)
         */
        async function readPngMetadata(data) {
            try {
                const textDecoder = new TextDecoder('utf-8');
                let offset = 8;
                const result = { prompt: null, workflow: null };

                while (offset < data.length - 12) {
                    const length = (data[offset] << 24) | (data[offset + 1] << 16) |
                                   (data[offset + 2] << 8) | data[offset + 3];

                    if (length < 0 || length > data.length - offset - 12) break;

                    const type = textDecoder.decode(data.slice(offset + 4, offset + 8));

                    if (type === 'tEXt' || type === 'iTXt') {
                        const chunkData = data.slice(offset + 8, offset + 8 + length);
                        const text = textDecoder.decode(chunkData);
                        const parsed = parsePngText(text);
                        // åˆå¹¶è§£æç»“æœ
                        if (parsed.prompt) result.prompt = parsed.prompt;
                        if (parsed.workflow) result.workflow = parsed.workflow;
                    }

                    if (type === 'IEND') break;
                    offset += 12 + length;
                }

                // å¦‚æœæ‰¾åˆ°äº† prompt æˆ– workflowï¼Œè¿”å›ç»“æœ
                if (result.prompt || result.workflow) {
                    return result;
                }
            } catch (e) {
                console.error('PNG metadata read error:', e);
            }
            return null;
        }

        /**
         * ä» Latent æ–‡ä»¶ä¸­è¯»å–å…ƒæ•°æ®
         * Latent æ ¼å¼: å‰8å­—èŠ‚æ˜¯å¤´éƒ¨å¤§å°ï¼Œåé¢æ˜¯ JSON æ ¼å¼çš„å¤´éƒ¨æ•°æ®
         * å¤´éƒ¨ä¸­åŒ…å« __metadata__ å­—æ®µï¼Œå…¶ä¸­æœ‰ prompt å’Œ workflow
         * è¿”å›æ ¼å¼: { prompt: {...}, workflow: {...} }
         */
        async function readLatentMetadata(data) {
            try {
                if (data.length < 8) return null;

                const headerSize = Number(
                    new BigUint64Array(data.slice(0, 8).buffer)[0]
                );

                if (headerSize < 0 || headerSize > data.length - 8) {
                    return null;
                }

                const textDecoder = new TextDecoder('utf-8');
                const headerJson = textDecoder.decode(
                    data.slice(8, 8 + headerSize)
                );

                const header = JSON.parse(headerJson);

                if (header.__metadata__) {
                    const metadata = header.__metadata__;
                    const result = { prompt: null, workflow: null };

                    // è§£æ prompt
                    if (metadata.prompt) {
                        try {
                            result.prompt = JSON.parse(metadata.prompt);
                        } catch {
                            result.prompt = metadata.prompt;
                        }
                    }

                    // è§£æ workflow
                    if (metadata.workflow) {
                        try {
                            result.workflow = JSON.parse(metadata.workflow);
                        } catch {
                            result.workflow = metadata.workflow;
                        }
                    }

                    // å¦‚æœæ‰¾åˆ°äº† prompt æˆ– workflowï¼Œè¿”å›ç»“æœ
                    if (result.prompt || result.workflow) {
                        return result;
                    }

                    return metadata;
                }

                return null;
            } catch (e) {
                console.error('Latent metadata read error:', e);
            }
            return null;
        }

        /**
         * è§£æ PNG tEXt chunk çš„æ–‡æœ¬æ•°æ®
         * æ ¼å¼: key\0value\0key\0value...
         * è¿”å›: { key: value, ... }
         */
        function parsePngText(text) {
            const result = {};
            const parts = text.split('\0');
            for (let i = 0; i < parts.length - 1; i += 2) {
                const key = parts[i];
                const value = parts[i + 1];
                if (key && value) {
                    result[key] = value;
                }
            }
            return result;
        }

        /**
         * è§£æå·¥ä½œæµå…ƒæ•°æ®ï¼Œå°† prompt æ ¼å¼è½¬æ¢ä¸ºå†…éƒ¨ä½¿ç”¨çš„æ•°æ®ç»“æ„
         *
         * è®¾è®¡åŸåˆ™ï¼š
         * - ä¼˜å…ˆä½¿ç”¨ prompt æ ¼å¼ (ComfyUI API æ ¼å¼)
         * - å¦‚æœæœ‰ workflow æ ¼å¼æ•°æ®ï¼Œæå–èŠ‚ç‚¹ä½ç½®ä¿¡æ¯
         * - å­å›¾é€šè¿‡èŠ‚ç‚¹ ID æ ¼å¼ "å­å›¾ID:èŠ‚ç‚¹ID" è¯†åˆ«
         *
         * è¾“å…¥æ ¼å¼ (metadata):
         * - PNG/Latent: { prompt: "{...}" } æˆ– { prompt: {...}, workflow: {...} }
         * - JSON: { prompt: {...}, workflow: {...} } (ä¸¤ç§æ ¼å¼å‡å·²æ”¯æŒ)
         *
         * è¾“å‡ºæ ¼å¼ (result):
         * - nodes: { èŠ‚ç‚¹ID: { inputs: {...}, class_type: "...", isSubgraphNode?, subgraphId?, subgraphName?, _meta?: { pos: [x, y], size: [w, h] } } }
         * - connections: [ { from, fromSlot, to, toSlot } ]
         * - notes: [ { id, text, mode } ]
         * - subgraphs: [ { id, name, nodes: [...] } ]
         * - nodePositions: { èŠ‚ç‚¹ID: { x, y } } - ä» workflow ä¸­æå–çš„èŠ‚ç‚¹ä½ç½®ï¼ˆå¦‚æœæœ‰ï¼‰
         */
        function parseWorkflow(metadata) {
            const result = {
                nodes: {},
                connections: [],
                notes: [],
                subgraphs: [],
                nodePositions: null,  // å­˜å‚¨ä» workflow ä¸­æå–çš„ä½ç½®ä¿¡æ¯
                xworkflowSaveNodes: [] // å­˜å‚¨ XWorkflowSave èŠ‚ç‚¹çš„IDåˆ—è¡¨
            };

            try {
                // æå– prompt æ•°æ®
                let promptData = null;

                if (metadata.prompt) {
                    promptData = typeof metadata.prompt === 'string' ?
                        JSON.parse(metadata.prompt) : metadata.prompt;
                }

                if (!promptData) {
                    console.error('No prompt data found in metadata');
                    return result;
                }

                // prompt æ ¼å¼ç›´æ¥æ˜¯èŠ‚ç‚¹æ˜ å°„è¡¨: { èŠ‚ç‚¹ID: èŠ‚ç‚¹æ•°æ®, ... }
                result.nodes = promptData;

                // æå– workflow ä¸­çš„èŠ‚ç‚¹ä½ç½®ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                if (metadata.workflow && metadata.workflow.nodes) {
                    result.nodePositions = {};
                    for (const node of metadata.workflow.nodes) {
                        if (node.pos && Array.isArray(node.pos) && node.pos.length >= 2) {
                            result.nodePositions[String(node.id)] = {
                                x: node.pos[0],
                                y: node.pos[1]
                            };
                        }
                    }
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•ä½ç½®ä¿¡æ¯ï¼Œè®¾ä¸º null
                    if (Object.keys(result.nodePositions).length === 0) {
                        result.nodePositions = null;
                    }
                }

                // å¤„ç†æ¯ä¸ªèŠ‚ç‚¹
                for (const [nodeId, nodeData] of Object.entries(promptData)) {
                    const inputs = nodeData.inputs || {};
                    const classType = nodeData.class_type;

                    // æ£€æµ‹ XWorkflowSave èŠ‚ç‚¹
                    if (classType === 'XWorkflowSave') {
                        result.xworkflowSaveNodes.push(nodeId);
                    }

                    // æå– Note èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ MarkdownNoteï¼‰
                    if (classType === 'Note' || classType === 'MarkdownNote') {
                        result.notes.push({
                            id: nodeId,
                            text: inputs.text || '',
                            mode: inputs.mode,
                            classType: classType
                        });
                    }

                    // æå–è¿æ¥å…³ç³»
                    // prompt ä¸­çš„è¾“å…¥æ ¼å¼: inputs: { å‚æ•°å: [æ¥æºèŠ‚ç‚¹ID, æ¥æºæ§½ä½], ... }
                    for (const [inputName, inputValue] of Object.entries(inputs)) {
                        if (Array.isArray(inputValue) && inputValue.length >= 2) {
                            const [fromNode, fromSlot] = inputValue;
                            result.connections.push({
                                from: fromNode,
                                fromSlot: fromSlot,
                                to: nodeId,
                                toSlot: inputName
                            });
                        }
                    }
                }

                // å¤„ç†å­å›¾
                // å­å›¾èŠ‚ç‚¹ ID æ ¼å¼: "å­å›¾ID:èŠ‚ç‚¹ID" (å¦‚ "18:8" è¡¨ç¤ºå­å›¾18ä¸­çš„èŠ‚ç‚¹8)
                const subgraphMap = new Map();
                for (const [nodeId, nodeData] of Object.entries(promptData)) {
                    if (nodeId.includes(':')) {
                        const [subgraphId, nodeIdPart] = nodeId.split(':');

                        // åˆ›å»ºå­å›¾è®°å½•
                        if (!subgraphMap.has(subgraphId)) {
                            subgraphMap.set(subgraphId, {
                                id: subgraphId,
                                name: `Subgraph ${subgraphId}`,
                                nodes: []
                            });
                        }

                        // æ·»åŠ èŠ‚ç‚¹åˆ°å­å›¾
                        subgraphMap.get(subgraphId).nodes.push({
                            id: nodeIdPart,
                            ...nodeData
                        });

                        // æ ‡è®°èŠ‚ç‚¹ä¸ºå­å›¾èŠ‚ç‚¹ï¼Œç”¨äºåç»­é¢œè‰²åˆ†é…
                        nodeData.isSubgraphNode = true;
                        nodeData.subgraphId = subgraphId;
                        nodeData.subgraphName = `Subgraph ${subgraphId}`;
                    }
                }

                // å°†å­å›¾æ˜ å°„è½¬æ¢ä¸ºæ•°ç»„
                if (subgraphMap.size > 0) {
                    result.subgraphs = Array.from(subgraphMap.values());
                }
            } catch (e) {
                console.error('Parse workflow error:', e);
            }

            return result;
        }

        /**
         * æ¸²æŸ“æ•´ä¸ªå·¥ä½œæµ
         * æµç¨‹ï¼šæ¸…ç†æ—§èµ„æº -> æ¸…ç©ºç”»å¸ƒ -> è®¡ç®—èŠ‚ç‚¹ä½ç½® -> æ¸²æŸ“èŠ‚ç‚¹ -> æ¸²æŸ“è¿æ¥çº¿
         */
        function renderWorkflow() {
            // æ¸…ç†æ—§çš„ ResizeObserverï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
            document.querySelectorAll('.node').forEach(node => {
                if (node._resizeObserver) {
                    node._resizeObserver.disconnect();
                    node._resizeObserver = null;
                }
            });

            // åœ¨æ¸…ç©ºç”»å¸ƒå‰ï¼Œä¿å­˜æ‰€æœ‰èŠ‚ç‚¹çš„å½“å‰ä½ç½®
            // è¿™æ ·å¯ä»¥ç¡®ä¿ç”¨æˆ·æ‹–åŠ¨åçš„ä½ç½®ä¸ä¼šä¸¢å¤±
            document.querySelectorAll('.node').forEach(node => {
                const nodeId = node.dataset.nodeId;
                if (nodeId) {
                    const left = parseFloat(node.style.left);
                    const top = parseFloat(node.style.top);
                    if (!isNaN(left) && !isNaN(top)) {
                        if (!workflowData.nodePositions) {
                            workflowData.nodePositions = {};
                        }
                        workflowData.nodePositions[nodeId] = { x: left, y: top };
                    }
                }
            });

            canvas.innerHTML = '';
            connectionsSvg.innerHTML = '';

            if (!workflowData || !workflowData.nodes) {
                return;
            }

            const nodeCount = Object.keys(workflowData.nodes).length;
            document.getElementById('infoNodeCount').textContent = nodeCount;

            const nodePositions = calculateNodePositions();
            renderNodes(nodePositions);
            updateConnectionPaths();
        }

        /**
         * è®¡ç®—èŠ‚ç‚¹ä½ç½®
         * ä¼˜å…ˆä½¿ç”¨ä» workflow ä¸­ä¿å­˜çš„åŸå§‹ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨è‡ªåŠ¨å±‚çº§å¸ƒå±€ç®—æ³•
         *
         * é€»è¾‘ï¼š
         * 1. å¦‚æœ workflowData.nodePositions å­˜åœ¨ï¼Œä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„ä½ç½®
         * 2. å¯¹äºæ²¡æœ‰ä¿å­˜ä½ç½®çš„èŠ‚ç‚¹ï¼Œä½¿ç”¨è‡ªåŠ¨å±‚çº§å¸ƒå±€ç®—æ³•è®¡ç®—
         * 3. å­å›¾èŠ‚ç‚¹ä¸ä¸»å›¾èŠ‚ç‚¹åˆ†å¼€å¤„ç†å±‚çº§
         *
         * @returns {Object} èŠ‚ç‚¹IDåˆ°ä½ç½®çš„æ˜ å°„ { èŠ‚ç‚¹ID: {x, y} }
         */
        function calculateNodePositions() {
            const positions = {};

            // ç¬¬ä¸€æ­¥ï¼šä¼˜å…ˆä½¿ç”¨ä» workflow ä¸­ä¿å­˜çš„åŸå§‹ä½ç½®
            if (workflowData.nodePositions) {
                for (const [nodeId, pos] of Object.entries(workflowData.nodePositions)) {
                    positions[nodeId] = { x: pos.x, y: pos.y };
                }
            }

            // ç¬¬äºŒæ­¥ï¼šä¸ºæ²¡æœ‰ä¿å­˜ä½ç½®çš„èŠ‚ç‚¹ä½¿ç”¨è‡ªåŠ¨å±‚çº§å¸ƒå±€ç®—æ³•
            const autoLayoutNodes = Object.keys(workflowData.nodes).filter(
                nodeId => !positions[nodeId]
            );

            if (autoLayoutNodes.length > 0) {
                const autoPositions = calculateAutoLayoutPositions(autoLayoutNodes, positions);
                Object.assign(positions, autoPositions);
            }

            return positions;
        }

        /**
         * è‡ªåŠ¨å±‚çº§å¸ƒå±€ç®—æ³•
         * ä¸ºæ²¡æœ‰ä¿å­˜ä½ç½®çš„èŠ‚ç‚¹è®¡ç®—ä½ç½®
         * @param {string[]} nodeIds - éœ€è¦è‡ªåŠ¨å¸ƒå±€çš„èŠ‚ç‚¹IDåˆ—è¡¨
         * @param {Object} savedPositions - å·²ä¿å­˜çš„èŠ‚ç‚¹ä½ç½®æ˜ å°„ï¼ˆç”¨äºè®¡ç®—è¾¹ç•Œï¼‰
         * @returns {Object} èŠ‚ç‚¹IDåˆ°ä½ç½®çš„æ˜ å°„
         */
        function calculateAutoLayoutPositions(nodeIds, savedPositions) {
            const positions = {};
            const nodeLevel = {};

            /**
             * é€’å½’è®¡ç®—èŠ‚ç‚¹çš„å±‚çº§ï¼ˆæ·±åº¦ï¼‰
             * å­å›¾èŠ‚ç‚¹çš„å±‚çº§è®¡ç®—ç‹¬ç«‹äºä¸»å›¾èŠ‚ç‚¹
             * @param {string} nodeId - èŠ‚ç‚¹ID
             * @returns {number} èŠ‚ç‚¹çš„å±‚çº§
             */
            function getLevel(nodeId) {
                if (nodeLevel[nodeId] !== undefined) return nodeLevel[nodeId];

                const node = workflowData.nodes[nodeId];
                if (!node) return 0;

                let maxInputLevel = 0;
                for (const input of Object.values(node.inputs || {})) {
                    if (Array.isArray(input) && input[0]) {
                        const inputNodeId = input[0];
                        const inputNode = workflowData.nodes[inputNodeId];

                        if (inputNode) {
                            const inputSubgraphId = inputNode.subgraphId;
                            const currentSubgraphId = node.subgraphId;

                            if (inputSubgraphId !== currentSubgraphId) {
                                maxInputLevel = Math.max(maxInputLevel, getLevel(inputNodeId) + 1);
                            } else {
                                maxInputLevel = Math.max(maxInputLevel, getLevel(inputNodeId));
                            }
                        }
                    }
                }

                nodeLevel[nodeId] = maxInputLevel + 1;
                return nodeLevel[nodeId];
            }

            // è®¡ç®—æ‰€æœ‰éœ€è¦è‡ªåŠ¨å¸ƒå±€çš„èŠ‚ç‚¹çš„å±‚çº§
            nodeIds.forEach(id => getLevel(id));

            // æŒ‰å±‚çº§åˆ†ç»„èŠ‚ç‚¹
            const levelNodes = {};
            for (const [id, level] of Object.entries(nodeLevel)) {
                if (!levelNodes[level]) levelNodes[level] = [];
                levelNodes[level].push(id);
            }

            // è®¡ç®—å·²ä¿å­˜ä½ç½®çš„èŠ‚ç‚¹çš„è¾¹ç•Œï¼Œç”¨äºç¡®å®šè‡ªåŠ¨å¸ƒå±€çš„èµ·å§‹ä½ç½®
            let maxSavedX = 0;
            let maxSavedY = 0;
            if (savedPositions) {
                for (const pos of Object.values(savedPositions)) {
                    maxSavedX = Math.max(maxSavedX, pos.x);
                    maxSavedY = Math.max(maxSavedY, pos.y);
                }
            }

            // ä¸ºæ¯ä¸ªèŠ‚ç‚¹è®¡ç®—å…·ä½“ä½ç½®
            const startX = maxSavedX > 0 ? maxSavedX + 300 : 50;
            for (const [level, nodes] of Object.entries(levelNodes)) {
                const levelNum = parseInt(level);
                nodes.forEach((nodeId, index) => {
                    const x = startX + levelNum * 260;  // æ¯å±‚æ°´å¹³é—´è· 260px
                    const y = 50 + index * 180 + (levelNodes[level].length > 1 ? 0 : 50);  // å‚ç›´é—´è· 180px
                    positions[nodeId] = { x, y };
                });
            }

            return positions;
        }

        /**
         * æ¸²æŸ“æ‰€æœ‰èŠ‚ç‚¹
         * ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»º DOM å…ƒç´ ï¼Œè®¾ç½®æ ·å¼ã€ä½ç½®ã€å†…å®¹å’Œäº‹ä»¶å¤„ç†
         * @param {Object} positions - èŠ‚ç‚¹IDåˆ°ä½ç½®çš„æ˜ å°„
         */
        function renderNodes(positions) {
            for (const [nodeId, nodeData] of Object.entries(workflowData.nodes)) {
                // ç¡®å®šèŠ‚ç‚¹ä½ç½®ï¼ˆä¼˜å…ˆä½¿ç”¨ä» workflow ä¸­ä¿å­˜çš„ä½ç½®ï¼‰
                const pos = positions[nodeId] || { x: 100, y: 100 };
                const classType = nodeData.class_type;

                // æ„å»ºèŠ‚ç‚¹ CSS ç±»å
                let className = 'node';
                if (classType === 'Note' || classType === 'MarkdownNote') className += ' note-node';
                if (nodeStates[nodeId]?.collapsed) className += ' collapsed';

                // åˆ›å»ºèŠ‚ç‚¹å…ƒç´ 
                const nodeEl = document.createElement('div');
                nodeEl.className = className;
                nodeEl.style.left = pos.x + 'px';
                nodeEl.style.top = pos.y + 'px';
                nodeEl.dataset.nodeId = nodeId;

                // æ¢å¤ä¿å­˜çš„èŠ‚ç‚¹å°ºå¯¸ - åªåœ¨èŠ‚ç‚¹æœªæŠ˜å æ—¶æ¢å¤ï¼Œé¿å…æŠ˜å çŠ¶æ€å°ºå¯¸è®¡ç®—é—®é¢˜
                if (nodeStates[nodeId]?.width && !nodeStates[nodeId]?.collapsed) {
                    nodeEl.style.width = nodeStates[nodeId].width + 'px';
                }
                if (nodeStates[nodeId]?.height && !nodeStates[nodeId]?.collapsed) {
                    nodeEl.style.height = nodeStates[nodeId].height + 'px';
                } else if (!nodeStates[nodeId]?.collapsed) {
                    // è®¾ç½®é»˜è®¤é«˜åº¦ï¼Œç¡®ä¿èŠ‚ç‚¹æœ‰åˆé€‚çš„é«˜åº¦æ˜¾ç¤ºå†…å®¹
                    nodeEl.style.height = 'auto';
                }

                // è®¾ç½®å­å›¾è¾¹æ¡†é¢œè‰²
                const subgraphColor = getSubgraphColor(nodeData.subgraphId);
                if (subgraphColor) {
                    nodeEl.style.borderColor = subgraphColor;
                    nodeEl.style.boxShadow = `0 4px 12px ${subgraphColor}40`;
                }
                const isCollapsed = nodeStates[nodeId]?.collapsed || false;

                let content = '';

                if (classType === 'Note' || classType === 'MarkdownNote') {
                    const noteDataItem = workflowData.notes.find(n => n.id === nodeId);
                    content = `
                        <div class="node-header" data-node-id="${nodeId}">
                            <button class="header-btn copy-title-btn" data-node="${nodeId}" data-title="${classType}" title="${t('copyTitle')}">ğŸ“‹</button>
                            <span class="node-header-text">${classType}</span>
                            <div class="header-actions">
                                <button class="header-btn toggle-btn" data-node="${nodeId}" title="${isCollapsed ? t('expand') : t('toggleCollapse')}">${isCollapsed ? 'â•' : 'â–'}</button>
                            </div>
                        </div>
                        <div class="node-body">
                            <div class="note-content">${escapeHtml(noteDataItem?.text || '')}</div>
                        </div>
                    `;
                } else {
                    const inputs = nodeData.inputs || {};
                    const displayInputs = Object.entries(inputs);

                    const subgraphTag = nodeData.subgraphName ?
                        `<div class="subgraph-tag" data-subgraph-color="${subgraphColor}">${escapeHtml(nodeData.subgraphName)} [${nodeId}]</div>` :
                        '';

                    const nodeIdTag = !nodeData.subgraphName ?
                        `<div class="node-id-tag">[${escapeHtml(nodeId)}]</div>` :
                        '';

                    content = `
                        <div class="node-header" data-node-id="${nodeId}">
                            <button class="header-btn copy-title-btn" data-node="${nodeId}" data-title="${classType}" title="${t('copyTitle')}">ğŸ“‹</button>
                            <span class="node-header-text">${classType}</span>
                            <div class="header-actions">
                                <button class="header-btn toggle-btn" data-node="${nodeId}" title="${isCollapsed ? t('expand') : t('toggleCollapse')}">${isCollapsed ? 'â•' : 'â–'}</button>
                            </div>
                        </div>
                        ${subgraphTag}
                        ${nodeIdTag}
                        <div class="node-body">
                            ${displayInputs.map(([key, value]) => `
                                <div class="param-row">
                                    <span class="param-key" title="${escapeHtml(key)}">${escapeHtml(key)}</span>
                                    <span class="param-value" title="${escapeHtml(String(value))}">${escapeHtml(truncateValue(value))}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                nodeEl.innerHTML = content;

                // æ·»åŠ 8ä¸ªæ–¹å‘çš„æ‹‰ä¼¸æ‰‹æŸ„
                const resizeHandles = ['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se'];
                resizeHandles.forEach(direction => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${direction}`;
                    handle.dataset.direction = direction;
                    handle.dataset.nodeId = nodeId;
                    nodeEl.appendChild(handle);
                });

                // å¤„ç†é•¿æ–‡æœ¬å‚æ•° - ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
                if (classType === 'Note' || classType === 'MarkdownNote') {
                    // Note èŠ‚ç‚¹ç‰¹æ®Šå¤„ç† - æ£€æŸ¥ note-content
                    try {
                        const noteContent = nodeEl.querySelector('.note-content');
                        if (noteContent) {
                            const text = noteContent.textContent;
                            if (needsVirtualScroll(text)) {
                                // è·å–å®Œæ•´å†…å®¹
                                const noteDataItem = workflowData.notes.find(n => n.id === nodeId);
                                const fullText = noteDataItem?.text || text;

                                // åˆ›å»ºè™šæ‹Ÿæ»šåŠ¨å®¹å™¨æ›¿æ¢åŸæœ‰å†…å®¹ï¼ˆNoteèŠ‚ç‚¹ä½¿ç”¨æ›´å°çš„é«˜åº¦ï¼‰
                                const longContainer = createLongTextContainer(fullText, 'content', { maxHeight: 150 });
                                noteContent.innerHTML = '';
                                noteContent.style.maxHeight = 'none';
                                noteContent.appendChild(longContainer);
                            }
                        }
                    } catch (error) {
                        console.error('Error processing Note node:', error);
                    }
                } else {
                    // æ™®é€šèŠ‚ç‚¹å¤„ç†å‚æ•°
                    try {
                        const nodeBody = nodeEl.querySelector('.node-body');
                        if (nodeBody) {
                            const paramRows = nodeBody.querySelectorAll('.param-row');
                            paramRows.forEach((row, index) => {
                                try {
                                    const keyEl = row.querySelector('.param-key');
                                    const valueEl = row.querySelector('.param-value');
                                    if (keyEl && valueEl) {
                                        const key = keyEl.textContent;
                                        const value = valueEl.textContent;

                                        // æ£€æŸ¥æ˜¯å¦éœ€è¦è™šæ‹Ÿæ»šåŠ¨
                                        if (needsVirtualScroll(value)) {
                                            // è·å–åŸå§‹å€¼ï¼ˆä» inputs ä¸­è·å–å®Œæ•´å†…å®¹ï¼‰
                                            let originalValue = nodeData.inputs?.[key] || value;
                                            // å¦‚æœæ˜¯æ•°ç»„ï¼Œè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                                            if (Array.isArray(originalValue)) {
                                                originalValue = JSON.stringify(originalValue);
                                            }
                                            const fullContent = String(originalValue);

                                            // æ›¿æ¢ä¸ºé•¿æ–‡æœ¬å®¹å™¨
                                            row.classList.add('long-param');
                                            const longContainer = createLongTextContainer(fullContent, key);

                                            // æ¸…ç©ºå¹¶æ·»åŠ æ–°å®¹å™¨
                                            valueEl.innerHTML = '';
                                            valueEl.className = 'param-value-container';
                                            valueEl.appendChild(longContainer);
                                        }
                                    }
                                } catch (paramError) {
                                    console.error('Error processing parameter:', paramError);
                                }
                            });
                        }
                    } catch (bodyError) {
                        console.error('Error processing node body:', bodyError);
                    }
                }

                const subgraphTagEl = nodeEl.querySelector('.subgraph-tag');
                if (subgraphTagEl && subgraphColor) {
                    subgraphTagEl.style.background = subgraphColor;
                    subgraphTagEl.style.borderBottomColor = subgraphColor;
                }

                nodeEl.addEventListener('click', (e) => {
                    e.stopPropagation();

                    // å¦‚æœåˆšåˆšå®Œæˆäº†æ‹–åŠ¨ï¼Œä¸æ‰§è¡Œç‚¹å‡»é€»è¾‘
                    if (justFinishedDrag) {
                        justFinishedDrag = false;
                        return;
                    }

                    // Ctrl+ç‚¹å‡»ï¼šåˆ‡æ¢å¤šé€‰çŠ¶æ€
                    if (e.ctrlKey) {
                        if (selectedNodeIds.has(nodeId)) {
                            selectedNodeIds.delete(nodeId);
                        } else {
                            selectedNodeIds.add(nodeId);
                        }
                        updateMultiSelection();
                        return;
                    }

                    // æ™®é€šç‚¹å‡»ï¼šå•é€‰
                    selectedNodeIds.clear();
                    updateMultiSelection();
                    selectNode(nodeId);
                });

                const header = nodeEl.querySelector('.node-header');
                let isNodeDragging = false;
                let hasDragStarted = false;
                let nodeDragStartX, nodeDragStartY, nodeStartX, nodeStartY;
                const DRAG_THRESHOLD = 3; // æ‹–åŠ¨é˜ˆå€¼ï¼ˆåƒç´ ï¼‰

                header.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('header-btn')) return;

                    // å¦‚æœç‚¹å‡»çš„èŠ‚ç‚¹åœ¨å¤šé€‰é›†åˆä¸­ï¼Œå¯åŠ¨å¤šèŠ‚ç‚¹æ‹–åŠ¨
                    if (selectedNodeIds.has(nodeId) && selectedNodeIds.size > 1) {
                        isMultiDragging = true;
                        multiDragStartX = e.clientX;
                        multiDragStartY = e.clientY;
                        multiDragNodePositions.clear();

                        // ä¿å­˜æ‰€æœ‰é€‰ä¸­èŠ‚ç‚¹çš„åˆå§‹ä½ç½®
                        selectedNodeIds.forEach(id => {
                            const el = document.querySelector(`[data-node-id="${id}"]`);
                            if (el) {
                                multiDragNodePositions.set(id, {
                                    x: parseFloat(el.style.left),
                                    y: parseFloat(el.style.top)
                                });
                            }
                        });

                        document.body.style.userSelect = 'none';
                        document.body.style.webkitUserSelect = 'none';
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }

                    // å•èŠ‚ç‚¹æ‹–åŠ¨
                    isNodeDragging = true;
                    hasDragStarted = false;
                    nodeDragStartX = e.clientX;
                    nodeDragStartY = e.clientY;
                    nodeStartX = parseFloat(nodeEl.style.left);
                    nodeStartY = parseFloat(nodeEl.style.top);
                    // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢æ–‡æœ¬é€‰æ‹©
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (isNodeDragging) {
                        const dx = e.clientX - nodeDragStartX;
                        const dy = e.clientY - nodeDragStartY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // åªæœ‰å½“ç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼æ—¶æ‰çœŸæ­£å¼€å§‹æ‹–åŠ¨
                        if (!hasDragStarted && distance > DRAG_THRESHOLD) {
                            hasDragStarted = true;
                            // å¼€å§‹æ‹–åŠ¨æ—¶é˜»æ­¢æ–‡æœ¬é€‰æ‹©å¹¶æ”¹å˜å…‰æ ‡æ ·å¼
                            header.classList.add('dragging');
                            document.body.style.userSelect = 'none';
                            document.body.style.webkitUserSelect = 'none';
                        }

                        if (hasDragStarted) {
                            const scaledDx = dx / scale;
                            const scaledDy = dy / scale;
                            nodeEl.style.left = (nodeStartX + scaledDx) + 'px';
                            nodeEl.style.top = (nodeStartY + scaledDy) + 'px';
                            updateConnectionPaths();
                            updateConnectionHighlight();
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isNodeDragging) {
                        // æ¢å¤æ–‡æœ¬é€‰æ‹©å’Œå…‰æ ‡æ ·å¼
                        header.classList.remove('dragging');
                        document.body.style.userSelect = '';
                        document.body.style.webkitUserSelect = '';

                        // åªæœ‰çœŸæ­£æ‹–åŠ¨è¿‡æ‰ä¿å­˜ä½ç½®
                        if (hasDragStarted) {
                            const newX = parseFloat(nodeEl.style.left);
                            const newY = parseFloat(nodeEl.style.top);
                            if (!workflowData.nodePositions) {
                                workflowData.nodePositions = {};
                            }
                            workflowData.nodePositions[nodeId] = { x: newX, y: newY };

                            // è®¾ç½®æ ‡è®°ï¼Œé˜²æ­¢è§¦å‘ç‚¹å‡»äº‹ä»¶
                            justFinishedDrag = true;
                            setTimeout(() => {
                                justFinishedDrag = false;
                            }, 50);
                        }
                    }
                    isNodeDragging = false;
                    hasDragStarted = false;
                });

                // ä¸ºæ‹‰ä¼¸æ‰‹æŸ„æ·»åŠ äº‹ä»¶ç›‘å¬
                nodeEl.querySelectorAll('.resize-handle').forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        // åˆå§‹åŒ–æ‹‰ä¼¸çŠ¶æ€
                        isResizing = true;
                        resizeNodeId = nodeId;
                        resizeDirection = handle.dataset.direction;
                        resizeStartX = e.clientX;
                        resizeStartY = e.clientY;
                        resizeStartWidth = nodeEl.offsetWidth;
                        resizeStartHeight = nodeEl.offsetHeight;
                        resizeStartLeft = parseFloat(nodeEl.style.left);
                        resizeStartTop = parseFloat(nodeEl.style.top);

                        // æ·»åŠ æ‹‰ä¼¸ä¸­æ ·å¼
                        nodeEl.classList.add('resizing');
                        handle.classList.add('active');

                        // é˜»æ­¢æ–‡æœ¬é€‰æ‹©
                        document.body.style.userSelect = 'none';
                        document.body.style.webkitUserSelect = 'none';
                    });
                });

                // ä½¿ç”¨ ResizeObserver ç›‘å¬èŠ‚ç‚¹å®½åº¦å˜åŒ–å¹¶ä¿å­˜
                // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿èŠ‚ç‚¹å·²å®Œå…¨æ¸²æŸ“
                requestAnimationFrame(() => {
                    let initialWidth = nodeEl.offsetWidth;
                    let isFirstObservation = true;

                    const resizeObserver = new ResizeObserver((entries) => {
                        for (const entry of entries) {
                            const width = entry.contentRect.width;
                            // è·³è¿‡ç¬¬ä¸€æ¬¡è§‚å¯Ÿï¼ˆåˆå§‹æ¸²æŸ“ï¼‰ï¼Œåªåœ¨ç”¨æˆ·æ‰‹åŠ¨è°ƒæ•´å¤§å°æ—¶ä¿å­˜
                            if (isFirstObservation) {
                                isFirstObservation = false;
                                initialWidth = width;
                                continue;
                            }
                            // åªåœ¨èŠ‚ç‚¹æœªæŠ˜å ä¸”å®½åº¦çœŸæ­£æ”¹å˜æ—¶ä¿å­˜
                            if (width > 0 && !nodeEl.classList.contains('collapsed') && Math.abs(width - initialWidth) > 1) {
                                nodeStates[nodeId] = nodeStates[nodeId] || {};
                                nodeStates[nodeId].width = width;
                                initialWidth = width;
                            }
                        }
                    });
                    resizeObserver.observe(nodeEl);

                    // ä¿å­˜ observer å¼•ç”¨ä»¥ä¾¿æ¸…ç†
                    nodeEl._resizeObserver = resizeObserver;
                });

                nodeEl.querySelectorAll('.header-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const nodeId = btn.dataset.node;

                        // å¤„ç†å¤åˆ¶æ ‡é¢˜æŒ‰é’®
                        if (btn.classList.contains('copy-title-btn')) {
                            const title = btn.dataset.title;
                            copyToClipboard(title);
                            return;
                        }

                        // å¤„ç†æŠ˜å /å±•å¼€æŒ‰é’®
                        nodeStates[nodeId] = nodeStates[nodeId] || {};
                        nodeStates[nodeId].collapsed = !nodeStates[nodeId].collapsed;
                        renderWorkflow();
                        setTimeout(updateTransform, 0);
                    });
                });

                // ä¸ºå‚æ•°å€¼æ·»åŠ æ»šè½®äº‹ä»¶ï¼Œå®ç°æ‚¬åœæ—¶æ»šåŠ¨
                nodeEl.querySelectorAll('.param-value').forEach(paramValue => {
                    paramValue.addEventListener('wheel', (e) => {
                        // æ£€æŸ¥å†…å®¹æ˜¯å¦è¶…å‡ºå¯è§†åŒºåŸŸ
                        const canScrollDown = paramValue.scrollHeight > paramValue.clientHeight;
                        const canScrollUp = paramValue.scrollTop > 0;
                        const canScroll = canScrollDown || canScrollUp;

                        if (canScroll) {
                            // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢ç”»å¸ƒç¼©æ”¾
                            e.stopPropagation();

                            // æ£€æŸ¥æ˜¯å¦æ»šåŠ¨åˆ°è¾¹ç•Œ
                            const isAtTop = paramValue.scrollTop <= 0 && e.deltaY < 0;
                            const isAtBottom = paramValue.scrollTop + paramValue.clientHeight >= paramValue.scrollHeight && e.deltaY > 0;

                            // åªæœ‰åœ¨æ²¡æœ‰åˆ°è¾¾è¾¹ç•Œæ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸º
                            if (!isAtTop && !isAtBottom) {
                                e.preventDefault();
                                paramValue.scrollTop += e.deltaY;
                            }
                        }
                    }, { passive: false });
                });

                // ä¸º Note å†…å®¹æ·»åŠ æ»šè½®äº‹ä»¶
                nodeEl.querySelectorAll('.note-content').forEach(noteContent => {
                    noteContent.addEventListener('wheel', (e) => {
                        // æ£€æŸ¥å†…å®¹æ˜¯å¦è¶…å‡ºå¯è§†åŒºåŸŸ
                        const canScrollDown = noteContent.scrollHeight > noteContent.clientHeight;
                        const canScrollUp = noteContent.scrollTop > 0;
                        const canScroll = canScrollDown || canScrollUp;

                        if (canScroll) {
                            // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢ç”»å¸ƒç¼©æ”¾
                            e.stopPropagation();

                            // æ£€æŸ¥æ˜¯å¦æ»šåŠ¨åˆ°è¾¹ç•Œ
                            const isAtTop = noteContent.scrollTop <= 0 && e.deltaY < 0;
                            const isAtBottom = noteContent.scrollTop + noteContent.clientHeight >= noteContent.scrollHeight && e.deltaY > 0;

                            // åªæœ‰åœ¨æ²¡æœ‰åˆ°è¾¾è¾¹ç•Œæ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸º
                            if (!isAtTop && !isAtBottom) {
                                e.preventDefault();
                                noteContent.scrollTop += e.deltaY;
                            }
                        }
                    }, { passive: false });
                });

                canvas.appendChild(nodeEl);
            }
        }

        /**
         * æˆªæ–­è¿‡é•¿çš„å‚æ•°å€¼ç”¨äºæ˜¾ç¤º
         * @param {*} value - å‚æ•°å€¼
         * @returns {string} æˆªæ–­åçš„å­—ç¬¦ä¸²
         */
        function truncateValue(value) {
            if (Array.isArray(value)) {
                if (value.length === 2 && typeof value[0] === 'string') {
                    return `[${value[0]}]`;
                }
                return `[${value.join(', ')}]`;
            }
            // ç©ºå­—ç¬¦ä¸²æ˜¾ç¤ºä¸º (empty)ï¼Œä»¥ä¾¿ç”¨æˆ·çŸ¥é“å‚æ•°å­˜åœ¨
            if (value === '') {
                return '(empty)';
            }
            return String(value);
        }

        /**
         * æ£€æµ‹å†…å®¹æ˜¯å¦éœ€è¦è™šæ‹Ÿæ»šåŠ¨
         * @param {string} content - å†…å®¹å­—ç¬¦ä¸²
         * @returns {boolean} æ˜¯å¦éœ€è¦è™šæ‹Ÿæ»šåŠ¨
         */
        function needsVirtualScroll(content) {
            if (!content || typeof content !== 'string') return false;
            return content.length > 5000 || content.split('\n').length > 100;
        }

        /**
         * å°†æ–‡æœ¬åˆ†å‰²æˆè¡Œ
         * @param {string} text - æ–‡æœ¬å†…å®¹
         * @param {number} maxLineLength - æ¯è¡Œæœ€å¤§é•¿åº¦
         * @returns {string[]} è¡Œæ•°ç»„
         */
        function splitIntoLines(text, maxLineLength = 200) {
            const rawLines = text.split('\n');
            const lines = [];

            for (const rawLine of rawLines) {
                if (rawLine.length <= maxLineLength) {
                    lines.push(rawLine);
                } else {
                    for (let i = 0; i < rawLine.length; i += maxLineLength) {
                        lines.push(rawLine.substring(i, i + maxLineLength));
                    }
                }
            }

            return lines;
        }

        /**
         * æ ¼å¼åŒ–å­—èŠ‚å¤§å°
         * @param {number} bytes - å­—èŠ‚æ•°
         * @returns {string} æ ¼å¼åŒ–åçš„å­—ç¬¦ä¸²
         */
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        /**
         * å¤åˆ¶æ–‡æœ¬åˆ°å‰ªè´´æ¿
         * @param {string} text - è¦å¤åˆ¶çš„æ–‡æœ¬
         */
        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                showToast(t('copied'));
            } catch (err) {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showToast(t('copied'));
            }
        }

        /**
         * ä¸‹è½½æ–‡æœ¬æ–‡ä»¶
         * @param {string} text - æ–‡æœ¬å†…å®¹
         * @param {string} filename - æ–‡ä»¶å
         */
        function downloadText(text, filename) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast(t('downloadStarted'));
        }

        /**
         * æ˜¾ç¤º Toast æç¤º
         * @param {string} message - æç¤ºæ¶ˆæ¯
         */
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast-message';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        /**
         * åˆ›å»ºè™šæ‹Ÿæ»šåŠ¨å®¹å™¨
         * @param {string} content - é•¿æ–‡æœ¬å†…å®¹
         * @param {Object} options - é…ç½®é€‰é¡¹
         * @returns {HTMLElement} è™šæ‹Ÿæ»šåŠ¨å®¹å™¨
         */
        function createVirtualScroll(content, options = {}) {
            try {
                const {
                    maxHeight = 200,
                    lineHeight = 16,
                    maxPreviewLength = 5000
                } = options;

                // ç¡®ä¿contentæ˜¯å­—ç¬¦ä¸²
                if (typeof content !== 'string') {
                    content = String(content);
                }

                if (content.length <= maxPreviewLength) {
                    const div = document.createElement('div');
                    div.className = 'param-value-short';
                    div.textContent = content;
                    return div;
                }

                const lines = splitIntoLines(content);
                const totalHeight = lines.length * lineHeight;

                const container = document.createElement('div');
                container.className = 'virtual-scroll-container';
                container.style.height = maxHeight + 'px';
                container.style.overflow = 'auto';
                container.style.position = 'relative';

                const spacer = document.createElement('div');
                spacer.className = 'virtual-scroll-spacer';
                spacer.style.height = totalHeight + 'px';
                container.appendChild(spacer);

                const visibleLayer = document.createElement('div');
                visibleLayer.className = 'virtual-scroll-visible';
                visibleLayer.style.position = 'absolute';
                visibleLayer.style.top = '0';
                visibleLayer.style.left = '0';
                visibleLayer.style.minWidth = '100%';
                container.appendChild(visibleLayer);

                const visibleCount = Math.ceil(maxHeight / lineHeight) + 2;

                const renderVisibleLines = () => {
                    const scrollTop = container.scrollTop;
                    const startIndex = Math.max(0, Math.floor(scrollTop / lineHeight));
                    const endIndex = Math.min(startIndex + visibleCount, lines.length);

                    const fragment = document.createDocumentFragment();
                    for (let i = startIndex; i < endIndex; i++) {
                        const lineEl = document.createElement('div');
                        lineEl.className = 'virtual-scroll-line';
                        lineEl.style.height = lineHeight + 'px';
                        lineEl.textContent = lines[i] || ' ';
                        fragment.appendChild(lineEl);
                    }

                    visibleLayer.innerHTML = '';
                    visibleLayer.appendChild(fragment);
                    visibleLayer.style.top = (startIndex * lineHeight) + 'px';
                };

            let ticking = false;
            container.addEventListener('scroll', () => {
                if (!ticking) {
                    requestAnimationFrame(() => {
                        renderVisibleLines();
                        ticking = false;
                    });
                    ticking = true;
                }
            });

            // æ·»åŠ æ»šè½®äº‹ä»¶æ”¯æŒ
            container.addEventListener('wheel', (e) => {
                // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘è§†å›¾ç¼©æ”¾
                e.stopPropagation();

                // å¤„ç†æ¨ªå‘æ»šåŠ¨ï¼ˆShift+æ»šè½®æˆ–æ¨ªå‘æ»šè½®ï¼‰
                if (e.shiftKey || e.deltaX !== 0) {
                    e.preventDefault();
                    container.scrollLeft += e.deltaX || e.deltaY;
                    return;
                }

                // å¤„ç†çºµå‘æ»šåŠ¨
                const isAtTop = container.scrollTop === 0 && e.deltaY < 0;
                const isAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 1 && e.deltaY > 0;

                // åªæœ‰åœ¨æ²¡æœ‰åˆ°è¾¾çºµå‘è¾¹ç•Œæ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸ºå¹¶æ»šåŠ¨
                if (!isAtTop && !isAtBottom) {
                    e.preventDefault();
                    container.scrollTop += e.deltaY;
                }
            }, { passive: false });

                renderVisibleLines();

                container.virtualScrollData = {
                    lines: lines,
                    getAllContent: () => content
                };

                return container;
            } catch (error) {
                console.error('createVirtualScroll error:', error);
                // å‡ºé”™æ—¶è¿”å›ä¸€ä¸ªç®€å•çš„divæ˜¾ç¤ºå†…å®¹
                const div = document.createElement('div');
                div.className = 'param-value-short';
                div.textContent = typeof content === 'string' ? content : String(content);
                return div;
            }
        }

        /**
         * åˆ›å»ºé•¿æ–‡æœ¬å®¹å™¨ï¼ˆå¸¦å¤´éƒ¨å’Œæ“ä½œæŒ‰é’®ï¼‰
         * @param {string} content - æ–‡æœ¬å†…å®¹
         * @param {string} paramKey - å‚æ•°å
         * @param {Object} options - é…ç½®é€‰é¡¹
         * @returns {HTMLElement} é•¿æ–‡æœ¬å®¹å™¨
         */
        function createLongTextContainer(content, paramKey, options = {}) {
            try {
                const wrapper = document.createElement('div');
                wrapper.className = 'long-text-wrapper';

                const header = document.createElement('div');
                header.className = 'long-text-header';
                header.innerHTML = `
                    <span class="long-text-info">${formatBytes(content.length)} Â· ${splitIntoLines(content).length.toLocaleString()} ${t('lines')}</span>
                    <div class="long-text-actions">
                        <button class="text-action-btn" data-action="copy">ğŸ“‹ ${t('copy')}</button>
                        <button class="text-action-btn" data-action="download">ğŸ’¾ ${t('download')}</button>
                    </div>
                `;
                wrapper.appendChild(header);

                const virtualScroll = createVirtualScroll(content, options);
                wrapper.appendChild(virtualScroll);

                header.querySelectorAll('.text-action-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = btn.dataset.action;
                        if (action === 'copy') {
                            copyToClipboard(content);
                        } else if (action === 'download') {
                            downloadText(content, `${paramKey}.txt`);
                        }
                    });
                });

                return wrapper;
            } catch (error) {
                console.error('createLongTextContainer error:', error);
                // å‡ºé”™æ—¶è¿”å›ä¸€ä¸ªç®€å•çš„divæ˜¾ç¤ºå†…å®¹
                const div = document.createElement('div');
                div.className = 'param-value-short';
                div.textContent = typeof content === 'string' ? content : String(content);
                return div;
            }
        }

        /**
         * æ›´æ–°è¿æ¥çº¿çš„ SVG è·¯å¾„
         * æ ¹æ®èŠ‚ç‚¹ä½ç½®è®¡ç®—è´å¡å°”æ›²çº¿è·¯å¾„ï¼Œè¿æ¥ç‚¹ä½äºèŠ‚ç‚¹è¾¹æ¡†ä¸Š
         */
        function updateConnectionPaths() {
            let svgContent = '';

            for (const conn of workflowData.connections) {
                const fromNodeEl = document.querySelector(`[data-node-id="${conn.from}"]`);
                const toNodeEl = document.querySelector(`[data-node-id="${conn.to}"]`);

                if (!fromNodeEl || !toNodeEl) continue;

                // è·å–èŠ‚ç‚¹ä½ç½®å’Œå°ºå¯¸
                const fromRect = {
                    x: parseFloat(fromNodeEl.style.left),
                    y: parseFloat(fromNodeEl.style.top),
                    width: fromNodeEl.offsetWidth,
                    height: fromNodeEl.offsetHeight
                };

                const toRect = {
                    x: parseFloat(toNodeEl.style.left),
                    y: parseFloat(toNodeEl.style.top),
                    width: toNodeEl.offsetWidth,
                    height: toNodeEl.offsetHeight
                };

                // è®¡ç®—è¿æ¥ç‚¹åæ ‡ï¼ˆä»å³ä¾§è¾¹æ¡†ä¸­ç‚¹å‡ºå‘ï¼Œåˆ°å·¦ä¾§è¾¹æ¡†ä¸­ç‚¹ï¼‰
                const dotRadius = 5; // åœ†ç‚¹åŠå¾„
                const x1 = fromRect.x + fromRect.width; // èµ·ç‚¹åœ¨å³è¾¹æ¡†
                const y1 = fromRect.y + fromRect.height / 2;
                const x2 = toRect.x; // ç»ˆç‚¹åœ¨å·¦è¾¹æ¡†
                const y2 = toRect.y + toRect.height / 2;

                // è®¡ç®—è´å¡å°”æ›²çº¿æ§åˆ¶ç‚¹
                const midX = (x1 + x2) / 2;

                // ç»˜åˆ¶è¿æ¥çº¿è·¯å¾„ï¼ˆä»åœ†ç‚¹è¾¹ç¼˜å¼€å§‹ï¼Œåˆ°åœ†ç‚¹è¾¹ç¼˜ç»“æŸï¼‰
                const path = `M ${x1 + dotRadius} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2 - dotRadius} ${y2}`;
                svgContent += `<path class="connection-line" d="${path}" data-from="${conn.from}" data-to="${conn.to}" />`;

                // æ·»åŠ èµ·ç‚¹åœ†ç‚¹ï¼ˆåœ¨å³è¾¹æ¡†ä¸Šï¼‰
                svgContent += `<circle class="connection-dot" cx="${x1}" cy="${y1}" r="${dotRadius}" data-dot-type="output" data-node="${conn.from}" />`;

                // æ·»åŠ ç»ˆç‚¹åœ†ç‚¹ï¼ˆåœ¨å·¦è¾¹æ¡†ä¸Šï¼‰
                svgContent += `<circle class="connection-dot" cx="${x2}" cy="${y2}" r="${dotRadius}" data-dot-type="input" data-node="${conn.to}" />`;
            }

            connectionsSvg.innerHTML = svgContent;

            const wrapperRect = canvasWrapper.getBoundingClientRect();
            connectionsSvg.setAttribute('viewBox', `0 0 ${wrapperRect.width} ${wrapperRect.height}`);
            connectionsSvg.style.width = wrapperRect.width + 'px';
            connectionsSvg.style.height = wrapperRect.height + 'px';

            updateConnectionHighlight();
        }

        /**
         * è½¬ä¹‰ HTML ç‰¹æ®Šå­—ç¬¦ï¼Œé˜²æ­¢ XSS æ”»å‡»
         * @param {string} text - åŸå§‹æ–‡æœ¬
         * @returns {string} è½¬ä¹‰åçš„ HTML å®‰å…¨æ–‡æœ¬
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * é€‰ä¸­æŒ‡å®šèŠ‚ç‚¹
         * æ·»åŠ é€‰ä¸­æ ·å¼å’Œå‘å…‰æ•ˆæœï¼Œå¹¶é«˜äº®ç›¸å…³è¿æ¥çº¿
         * @param {string} nodeId - èŠ‚ç‚¹ID
         */
        function selectNode(nodeId) {
            // æ¸…é™¤æ‰€æœ‰èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('selected');
                node.style.boxShadow = '';
            });

            const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.classList.add('selected');
                selectedNodeId = nodeId;

                // æ ¹æ®å­å›¾IDè·å–å‘å…‰é¢œè‰²
                const nodeData = workflowData ? Object.entries(workflowData.nodes || {}).find(([id]) => id === nodeId)?.[1] : null;
                const subgraphId = nodeData?.subgraphId;
                const glowColor = subgraphId ? getSubgraphColor(subgraphId) : '#cccccc';
                const rgb = hexToRgb(glowColor);

                // è®¾ç½®å¤šå±‚å‘å…‰æ•ˆæœ
                nodeEl.style.boxShadow = `0 0 20px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6), 0 0 40px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4), 0 0 0 2px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3) !important`;

                updateConnectionHighlight();
            }
        }

        /**
         * å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º RGB å¯¹è±¡
         * @param {string} hex - åå…­è¿›åˆ¶é¢œè‰²å€¼ï¼ˆå¦‚ #ff69b4ï¼‰
         * @returns {Object} åŒ…å« r, g, b å±æ€§çš„å¯¹è±¡
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 200, g: 200, b: 200 };
        }

        /**
         * å–æ¶ˆæ‰€æœ‰èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€
         * æ¸…é™¤é€‰ä¸­æ ·å¼ã€å‘å…‰æ•ˆæœå’Œè¿æ¥çº¿é«˜äº®
         */
        function deselectAll() {
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('selected');
                node.style.boxShadow = '';
            });
            document.querySelectorAll('.connection-line-flow').forEach(line => {
                line.remove();
            });
            document.querySelectorAll('.connection-line').forEach(line => {
                delete line.dataset.hasFlow;
            });
            document.querySelectorAll('.connection-dot').forEach(dot => {
                dot.classList.remove('highlight');
            });
            selectedNodeId = null;
        }

        /**
         * æ›´æ–°è¿æ¥çº¿çš„é«˜äº®çŠ¶æ€
         * å½“èŠ‚ç‚¹è¢«é€‰ä¸­æ—¶ï¼Œé«˜äº®ä¸è¯¥èŠ‚ç‚¹ç›¸å…³çš„è¿æ¥çº¿å’Œè¿æ¥ç‚¹
         */
        function updateConnectionHighlight() {
            if (!selectedNodeId) {
                document.querySelectorAll('.connection-line-flow').forEach(line => {
                    line.remove();
                });
                document.querySelectorAll('.connection-line').forEach(line => {
                    delete line.dataset.hasFlow;
                });
                document.querySelectorAll('.connection-dot').forEach(dot => {
                    dot.classList.remove('highlight');
                });
                return;
            }

            document.querySelectorAll('.connection-line').forEach(line => {
                const fromNodeId = line.dataset.from;
                const toNodeId = line.dataset.to;

                // å¦‚æœè¿æ¥çº¿ä¸é€‰ä¸­èŠ‚ç‚¹ç›¸å…³ï¼Œæ·»åŠ æµåŠ¨æ•ˆæœ
                if (fromNodeId === selectedNodeId || toNodeId === selectedNodeId) {
                    if (!line.dataset.hasFlow) {
                        const d = line.getAttribute('d');
                        const flowLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        flowLine.setAttribute('d', d);
                        flowLine.setAttribute('class', 'connection-line-flow');
                        flowLine.setAttribute('data-from', fromNodeId);
                        flowLine.setAttribute('data-to', toNodeId);
                        connectionsSvg.appendChild(flowLine);
                        line.dataset.hasFlow = 'true';
                    }
                } else {
                    if (line.dataset.hasFlow === 'true') {
                        line.dataset.hasFlow = 'false';
                        const flowLine = connectionsSvg.querySelector(`.connection-line-flow[data-from="${fromNodeId}"][data-to="${toNodeId}"]`);
                        if (flowLine) {
                            flowLine.remove();
                        }
                    }
                }
            });

            // é«˜äº®ç›¸å…³çš„è¿æ¥ç‚¹
            document.querySelectorAll('.connection-dot').forEach(dot => {
                const dotNodeId = dot.dataset.node;
                if (dotNodeId === selectedNodeId) {
                    dot.classList.add('highlight');
                } else {
                    dot.classList.remove('highlight');
                }
            });
        }
    </script>
</body>
</html>
